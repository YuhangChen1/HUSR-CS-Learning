#include <cstdio>
#include <cstring>
#include <stdexcept>
#include <iostream>
#include <cmath> 
#include <ctime>
#include<bits\stdc++.h>
#include "X_sudoku.h"
#include "solver.h"
using namespace std;

int translate_hive(int i, int j, int k) // 三元坐标转化为绝对坐标
{
    return (i-1)*81+(j-1)*9+k;
}

void head(FILE* fp)
{
    int i, j, k, k1, k2;
    
    // 每个格子约束 
    for (i = 1; i <= 9; i++) 
    {
        for (j = 1; j <= 9; j++)
        {
            // 每个格子必须填一个数字
            for (k = 1; k <= 9; k++)
            {
                fprintf(fp, "%d ", translate_hive(i, j, k));
            }
            fprintf(fp, "0\n");

            // 每个格子不能填两个不同的数字
            for (k1 = 1; k1 <= 8; k1++)
            {
                for (k2 = k1 + 1; k2 <= 9; k2++)
                {
                    fprintf(fp, "-%d -%d 0\n", translate_hive(i, j, k1), translate_hive(i, j, k2));
                }
            }
        }
    }

    // 行、列查重约束
    for (k = 1; k <= 9; k++)
    {
        for (i = 1; i <= 9; i++)
        {
            for (int j1 = 1; j1 <= 8; j1++)
            {
                for (int j2 = j1 + 1; j2 <= 9; j2++)
                {
                    // 行查重
                    fprintf(fp, "-%d -%d 0\n", translate_hive(i, j1, k), translate_hive(i, j2, k));
                    // 列查重
                    fprintf(fp, "-%d -%d 0\n", translate_hive(j1, i, k), translate_hive(j2, i, k));
                }
            }
        }
    }

    // 对角线查重约束
    for (k = 1; k <= 9; k++)
    {
        // 主对角线 (从左上到右下)
        for (i = 1; i <= 8; i++)
        {
            for (j = i + 1; j <= 9; j++)
            {
                fprintf(fp, "-%d -%d 0\n", translate_hive(i, i, k), translate_hive(j, j, k));
            }
        }

        // 副对角线 (从右上到左下)
        for (i = 1; i <= 8; i++)
        {
            for (j = i + 1; j <= 9; j++)
            {
                fprintf(fp, "-%d -%d 0\n", translate_hive(i, 10 - i, k), translate_hive(j, 10 - j, k));
            }
        }
    }
}


void reduction(int &i, int &j, int &k, int n) // 绝对坐标翻译为三元坐标
{
    k = n % 9;
    if (k == 0)
    {
        k = 9;
        n -= 9;
    }
    n /= 9;
    j = n % 9 + 1;
    i = n / 9 + 1;
}

Hanidoku::Hanidoku() // 空数独
{
    for (int i = 0; i < 9; i++) for (int j = 0; j < 9; j++) mymap[i][j] = 0;
}

void Hanidoku::load(const char* const filename) // 从res文件中读取
{
    FILE* fp = fopen(filename, "r");
    while (fgetc(fp) != 'v'); // 一直读取到v为止
    int i, j, k, n, t;
    for (i = 0; i < 9; i++) for (j = 0; j < 9; j++) mymap[i][j] = 0;

    for (t = 0; t < 729; t++)
    {
        fscanf(fp, "%d", &n);
        if (n > 0)
        {
            reduction(i, j, k, n);
            cell(i, j) = k;
        }
    }
    fclose(fp);
    return;
}

int& Hanidoku::cell(int x, int y) // 取第x行第y个格子，xy从1开始
{
    if (!legal(x, y)) throw runtime_error("Sudoku.cell不合法访问");
    return mymap[x - 1][y - 1];
}

bool Hanidoku::legal(int x, int y) // 一个坐标是否合法
{
    if (x < 1 || x > 9 || y < 1 || y > 9)
        return false;
    return true;
}

void Hanidoku::print()
{
    for (int i = 0; i < 9; i++)
    {
        for (int j = 0; j < 9; j++)
            printf("| %c ", (mymap[i][j]) ? (mymap[i][j] + '0') : '.');
        printf("|\n");
    }
}

void Hanidoku::generate_cnf(const char* const filename) // 根据Sudoku生成对应的cnf
{
    FILE* fp = fopen(filename, "w"); // 新建文件
    fprintf(fp, "c generated by cnf_developer.generate_cnf()\np cnf ");
    
    fprintf(fp, "729 %d\n", 8829 + content_num()); // 729变量，基础8829行
    head(fp);

    for (int i = 1; i <= 9; i++)
    {
        for (int j = 1; j <= 9; j++)
        {
            if (cell(i, j))
            {
                fprintf(fp, "%d 0\n", translate_hive(i, j, cell(i, j)));
            }
        }
    }

    fclose(fp);
}

int Hanidoku::content_num() // 返回自己已经填了的格子的数量
{
    int n = 0, i, j;
    for (i = 0; i < 9; i++) for (j = 0; j < 9; j++) if (mymap[i][j]) n++;
    return n;
}

void Hanidoku::randomGenerate(int n) // 生成随机数独题目，n为提示数
{
    int i, j, m;
    bool broke;
    for (i = 0; i < 9; i++) for (j = 0; j < 9; j++) mymap[i][j] = 0; // 初始化

    if (n == 0) return;

    generate_cnf("temp\\tempCNF.cnf");
    crossCNF cnf("temp\\tempCNF.cnf");

    cnf.solve("temp\\tempRES.res", false); // 主要耗时

    load("temp\\tempRES.res");

    int del = 0;
    while (81 - del > n)
    {
        // 随机挑选一个元素进行删除
        m = rand() % (81 - del);
        broke = false;
        for (i = 1; i <= 9 && !broke; i++)
        {
            for (j = 1; j <= 9; j++)
            {
                if (cell(i, j))
                {
                    m--;
                    if (m == 0)
                    {
                        cell(i, j) = 0;
                        del++;
                        broke = true;
                        break;
                    }
                }
            }
        }
    }
}



bool hasUniqueSolution() {
    // 第一次求解，得到一个解
    vector<int> firstSolution ; // 调用 SAT 求解器获取解，返回的是一个向量

    if (firstSolution.empty()) {
        // 没有解，返回 false
        return false;
    }

    // 构建新的约束条件，避免再次生成相同的解
    vector<int> newConstraint;
    for (size_t i = 0; i < firstSolution.size(); ++i) {
        if (firstSolution[i] > 0) {
            newConstraint.push_back(-firstSolution[i]); // 取反，表示至少有一个值与第一次不同
        }
    }

    // 加入新的约束，并尝试再次求解
// 直接在内存中添加约束，不通过文件
    vector<int> secondSolution; // 再次求解

    if (secondSolution.empty()) {
        // 没有第二个解，说明唯一解存在
        return true;
    } else {
        // 存在第二个解，说明不唯一
        return false;
    }
}
















































































































































































































































































































































































































































































































































































































































void Hanidoku:: randomGenerateshow(int n,int wi)
{
	if(wi==0)
	{
	int value[9][9] = {
    {3, 5, 1, 6, 4, 7, 2, 8, 9},
    {2, 6, 9, 3, 1, 8, 7, 5, 4},
    {4, 7, 8, 2, 9, 5, 1, 6, 3},
    {1, 2, 3, 7, 5, 6, 9, 4, 8},
    {9, 4, 5, 8, 2, 1, 6, 3, 7},
    {7, 8, 6, 4, 3, 9, 5, 2, 1},
    {6, 1, 7, 5, 8, 3, 4, 9, 2},
    {5, 3, 2, 9, 7, 4, 8, 1, 6},
    {8, 9, 4, 1, 6, 2, 3, 7, 5}
};
  std::vector<int> indices;
    for (int i = 0; i < 81; ++i) {
        indices.push_back(i);
    }

    // 2. 随机打乱索引列表
    std::srand(std::time(0));  // 初始化随机数种子
    std::random_shuffle(indices.begin(), indices.end());

    // 3. 删除前 n 个格子的数字
    for (int i = 0; i < n; ++i) {
        int index = indices[i];
        int row = index / 9;       // 计算行号
        int col = index % 9;       // 计算列号

        // 将指定位置的数字重置为 0
        value[row][col] = 0;
    }
        for (int i = 0; i < 9; i++) {
        for (int j = 0; j <9; j++) {
            mymap[i][j] = value[i][j];
        }
    }
	}
	if(wi==1)
	{
int value[9][9] = {
    {8, 3, 5, 2, 4, 7, 1, 9, 6},
    {4, 1, 7, 3, 9, 6, 5, 2, 8},
    {6, 9, 2, 8, 5, 1, 3, 7, 4},
    {1, 2, 9, 6, 8, 5, 4, 3, 7},
    {3, 5, 6, 4, 7, 9, 8, 1, 2},
    {7, 4, 8, 1, 2, 3, 6, 5, 9},
    {2, 7, 4, 5, 3, 8, 9, 6, 1},
    {5, 8, 1, 9, 6, 2, 7, 4, 3},
    {9, 6, 3, 7, 1, 4, 2, 8, 5}
};
  std::vector<int> indices;
    for (int i = 0; i < 81; ++i) {
        indices.push_back(i);
    }

    // 2. 随机打乱索引列表
    std::srand(std::time(0));  // 初始化随机数种子
    std::random_shuffle(indices.begin(), indices.end());

    // 3. 删除前 n 个格子的数字
    for (int i = 0; i < n; ++i) {
        int index = indices[i];
        int row = index / 9;       // 计算行号
        int col = index % 9;       // 计算列号

        // 将指定位置的数字重置为 0
        value[row][col] = 0;
    }
        for (int i = 0; i < 9; i++) {
        for (int j = 0; j <9; j++) {
            mymap[i][j] = value[i][j];
        }
    }
	}
	
	
		if(wi==2)
	{
	int value[9][9] = {
    {4, 8, 6, 2, 1, 3, 5, 7, 9},
    {9, 1, 7, 4, 8, 5, 3, 6, 2},
    {3, 5, 2, 6, 9, 7, 1, 4, 8},
    {6, 3, 4, 8, 5, 2, 7, 9, 1},
    {8, 2, 5, 1, 7, 9, 6, 3, 4},
    {1, 7, 9, 3, 4, 6, 2, 8, 5},
    {2, 6, 8, 5, 3, 4, 9, 1, 7},
    {7, 4, 3, 9, 2, 1, 8, 5, 6},
    {5, 9, 1, 7, 6, 8, 4, 2, 3}
};
  std::vector<int> indices;
    for (int i = 0; i < 81; ++i) {
        indices.push_back(i);
    }

    // 2. 随机打乱索引列表
    std::srand(std::time(0));  // 初始化随机数种子
    std::random_shuffle(indices.begin(), indices.end());

    // 3. 删除前 n 个格子的数字
    for (int i = 0; i < n; ++i) {
        int index = indices[i];
        int row = index / 9;       // 计算行号
        int col = index % 9;       // 计算列号

        // 将指定位置的数字重置为 0
        value[row][col] = 0;
    }
        for (int i = 0; i < 9; i++) {
        for (int j = 0; j <9; j++) {
            mymap[i][j] = value[i][j];
        }
    }
	}
if(wi==3)
{
	int value[9][9] = {
    {2, 9, 7, 5, 8, 4, 6, 3, 1},
    {8, 5, 3, 9, 6, 1, 4, 7, 2},
    {4, 1, 6, 3, 2, 7, 8, 9, 5},
    {9, 2, 4, 7, 3, 5, 1, 6, 8},
    {7, 8, 1, 6, 4, 9, 2, 5, 3},
    {3, 6, 5, 2, 1, 8, 9, 4, 7},
    {1, 7, 9, 8, 5, 6, 3, 2, 4},
    {5, 3, 8, 4, 9, 2, 7, 1, 6},
    {6, 4, 2, 1, 7, 3, 5, 8, 9}
};
  std::vector<int> indices;
    for (int i = 0; i < 81; ++i) {
        indices.push_back(i);
    }

    // 2. 随机打乱索引列表
    std::srand(std::time(0));  // 初始化随机数种子
    std::random_shuffle(indices.begin(), indices.end());

    // 3. 删除前 n 个格子的数字
    for (int i = 0; i < n; ++i) {
        int index = indices[i];
        int row = index / 9;       // 计算行号
        int col = index % 9;       // 计算列号

        // 将指定位置的数字重置为 0
        value[row][col] = 0;
    }
        for (int i = 0; i < 9; i++) {
        for (int j = 0; j <9; j++) {
            mymap[i][j] = value[i][j];
        }
    }
}
if(wi==4)
{
int value[9][9] = {
    {6, 4, 9, 8, 2, 7, 5, 1, 3},
    {2, 1, 3, 5, 4, 9, 8, 6, 7},
    {8, 7, 5, 1, 3, 6, 9, 4, 2},
    {4, 9, 2, 3, 1, 8, 7, 5, 6},
    {1, 3, 8, 6, 7, 5, 2, 9, 4},
    {7, 5, 6, 4, 9, 2, 1, 3, 8},
    {9, 8, 1, 7, 6, 3, 4, 2, 5},
    {3, 2, 7, 9, 5, 4, 6, 8, 1},
    {5, 6, 4, 2, 8, 1, 3, 7, 9}
};
  std::vector<int> indices;
    for (int i = 0; i < 81; ++i) {
        indices.push_back(i);
    }

    // 2. 随机打乱索引列表
    std::srand(std::time(0));  // 初始化随机数种子
    std::random_shuffle(indices.begin(), indices.end());

    // 3. 删除前 n 个格子的数字
    for (int i = 0; i < n; ++i) {
        int index = indices[i];
        int row = index / 9;       // 计算行号
        int col = index % 9;       // 计算列号

        // 将指定位置的数字重置为 0
        value[row][col] = 0;
    }
        for (int i = 0; i < 9; i++) {
        for (int j = 0; j <9; j++) {
            mymap[i][j] = value[i][j];
        }
    }
}
if(wi==5)
{
int value[9][9] = {
    {3, 7, 5, 8, 1, 6, 9, 4, 2},
    {8, 4, 9, 5, 2, 7, 3, 1, 6},
    {1, 2, 6, 9, 3, 4, 5, 7, 8},
    {5, 9, 3, 1, 7, 8, 6, 2, 4},
    {6, 1, 2, 4, 9, 3, 7, 8, 5},
    {7, 8, 4, 6, 5, 2, 1, 3, 9},
    {9, 5, 7, 2, 4, 1, 8, 6, 3},
    {2, 3, 8, 7, 6, 9, 4, 5, 1},
    {4, 6, 1, 3, 8, 5, 2, 9, 7}
};
  std::vector<int> indices;
    for (int i = 0; i < 81; ++i) {
        indices.push_back(i);
    }

    // 2. 随机打乱索引列表
    std::srand(std::time(0));  // 初始化随机数种子
    std::random_shuffle(indices.begin(), indices.end());

    // 3. 删除前 n 个格子的数字
    for (int i = 0; i < n; ++i) {
        int index = indices[i];
        int row = index / 9;       // 计算行号
        int col = index % 9;       // 计算列号

        // 将指定位置的数字重置为 0
        value[row][col] = 0;
    }
        for (int i = 0; i < 9; i++) {
        for (int j = 0; j <9; j++) {
            mymap[i][j] = value[i][j];
        }
    }
}

if(wi==6)
{
int value[9][9] = {
    {8, 3, 9, 7, 1, 4, 5, 2, 6},
    {6, 7, 1, 5, 8, 2, 4, 9, 3},
    {2, 5, 4, 3, 9, 6, 7, 8, 1},
    {9, 6, 7, 1, 2, 3, 8, 5, 4},
    {4, 1, 3, 8, 5, 7, 2, 6, 9},
    {5, 8, 2, 4, 6, 9, 3, 1, 7},
    {3, 9, 8, 2, 7, 1, 6, 4, 5},
    {7, 2, 6, 9, 4, 5, 1, 3, 8},
    {1, 4, 5, 6, 3, 8, 9, 7, 2}
};
  std::vector<int> indices;
    for (int i = 0; i < 81; ++i) {
        indices.push_back(i);
    }

    // 2. 随机打乱索引列表
    std::srand(std::time(0));  // 初始化随机数种子
    std::random_shuffle(indices.begin(), indices.end());

    // 3. 删除前 n 个格子的数字
    for (int i = 0; i < n; ++i) {
        int index = indices[i];
        int row = index / 9;       // 计算行号
        int col = index % 9;       // 计算列号

        // 将指定位置的数字重置为 0
        value[row][col] = 0;
    }
        for (int i = 0; i < 9; i++) {
        for (int j = 0; j <9; j++) {
            mymap[i][j] = value[i][j];
        }
    }
}

if(wi==7)
{
int value[9][9] = {
    {6, 1, 8, 5, 2, 7, 3, 9, 4},
    {3, 2, 9, 1, 4, 6, 7, 8, 5},
    {4, 5, 7, 9, 8, 3, 2, 6, 1},
    {7, 4, 6, 8, 3, 5, 1, 2, 9},
    {8, 9, 5, 2, 1, 4, 6, 3, 7},
    {1, 3, 2, 6, 7, 9, 4, 5, 8},
    {2, 8, 3, 4, 9, 1, 5, 7, 6},
    {5, 7, 1, 3, 6, 8, 9, 4, 2},
    {9, 6, 4, 7, 5, 2, 8, 1, 3}
};
  std::vector<int> indices;
    for (int i = 0; i < 81; ++i) {
        indices.push_back(i);
    }

    // 2. 随机打乱索引列表
    std::srand(std::time(0));  // 初始化随机数种子
    std::random_shuffle(indices.begin(), indices.end());

    // 3. 删除前 n 个格子的数字
    for (int i = 0; i < n; ++i) {
        int index = indices[i];
        int row = index / 9;       // 计算行号
        int col = index % 9;       // 计算列号

        // 将指定位置的数字重置为 0
        value[row][col] = 0;
    }
        for (int i = 0; i < 9; i++) {
        for (int j = 0; j <9; j++) {
            mymap[i][j] = value[i][j];
        }
    }
}

if(wi==8)
{
int value[9][9] = {
    {4, 9, 1, 6, 5, 7, 8, 3, 2},
    {8, 2, 7, 4, 1, 3, 6, 9, 5},
    {6, 5, 3, 2, 9, 8, 4, 7, 1},
    {5, 4, 9, 8, 2, 1, 7, 6, 3},
    {7, 3, 2, 5, 6, 4, 9, 1, 8},
    {1, 6, 8, 7, 3, 9, 5, 2, 4},
    {9, 7, 5, 3, 8, 2, 1, 4, 6},
    {2, 8, 4, 1, 7, 6, 3, 5, 9},
    {3, 1, 6, 9, 4, 5, 2, 8, 7}
};
  std::vector<int> indices;
    for (int i = 0; i < 81; ++i) {
        indices.push_back(i);
    }

    // 2. 随机打乱索引列表
    std::srand(std::time(0));  // 初始化随机数种子
    std::random_shuffle(indices.begin(), indices.end());

    // 3. 删除前 n 个格子的数字
    for (int i = 0; i < n; ++i) {
        int index = indices[i];
        int row = index / 9;       // 计算行号
        int col = index % 9;       // 计算列号

        // 将指定位置的数字重置为 0
        value[row][col] = 0;
    }
        for (int i = 0; i < 9; i++) {
        for (int j = 0; j <9; j++) {
            mymap[i][j] = value[i][j];
        }
    }
}

}









void Hanidoku::checkkk(int wi)
{
	if(wi==0)
	{
	int value[9][9] = {
    {3, 5, 1, 6, 4, 7, 2, 8, 9},
    {2, 6, 9, 3, 1, 8, 7, 5, 4},
    {4, 7, 8, 2, 9, 5, 1, 6, 3},
    {1, 2, 3, 7, 5, 6, 9, 4, 8},
    {9, 4, 5, 8, 2, 1, 6, 3, 7},
    {7, 8, 6, 4, 3, 9, 5, 2, 1},
    {6, 1, 7, 5, 8, 3, 4, 9, 2},
    {5, 3, 2, 9, 7, 4, 8, 1, 6},
    {8, 9, 4, 1, 6, 2, 3, 7, 5}
};
 for (int i = 0; i < 9; i++) {
        for (int j = 0; j < 9; j++) {
            mymap[i][j] = value[i][j];
        }
    }
	}
	if(wi==1)
	{
int value[9][9] = {
    {8, 3, 5, 2, 4, 7, 1, 9, 6},
    {4, 1, 7, 3, 9, 6, 5, 2, 8},
    {6, 9, 2, 8, 5, 1, 3, 7, 4},
    {1, 2, 9, 6, 8, 5, 4, 3, 7},
    {3, 5, 6, 4, 7, 9, 8, 1, 2},
    {7, 4, 8, 1, 2, 3, 6, 5, 9},
    {2, 7, 4, 5, 3, 8, 9, 6, 1},
    {5, 8, 1, 9, 6, 2, 7, 4, 3},
    {9, 6, 3, 7, 1, 4, 2, 8, 5}
};
 for (int i = 0; i < 9; i++) {
        for (int j = 0; j < 9; j++) {
            mymap[i][j] = value[i][j];
        }
    }
	}
	
	
		if(wi==2)
	{
	int value[9][9] = {
    {4, 8, 6, 2, 1, 3, 5, 7, 9},
    {9, 1, 7, 4, 8, 5, 3, 6, 2},
    {3, 5, 2, 6, 9, 7, 1, 4, 8},
    {6, 3, 4, 8, 5, 2, 7, 9, 1},
    {8, 2, 5, 1, 7, 9, 6, 3, 4},
    {1, 7, 9, 3, 4, 6, 2, 8, 5},
    {2, 6, 8, 5, 3, 4, 9, 1, 7},
    {7, 4, 3, 9, 2, 1, 8, 5, 6},
    {5, 9, 1, 7, 6, 8, 4, 2, 3}
};
 for (int i = 0; i < 9; i++) {
        for (int j = 0; j < 9; j++) {
            mymap[i][j] = value[i][j];
        }
    }
	}
if(wi==3)
{
	int value[9][9] = {
    {2, 9, 7, 5, 8, 4, 6, 3, 1},
    {8, 5, 3, 9, 6, 1, 4, 7, 2},
    {4, 1, 6, 3, 2, 7, 8, 9, 5},
    {9, 2, 4, 7, 3, 5, 1, 6, 8},
    {7, 8, 1, 6, 4, 9, 2, 5, 3},
    {3, 6, 5, 2, 1, 8, 9, 4, 7},
    {1, 7, 9, 8, 5, 6, 3, 2, 4},
    {5, 3, 8, 4, 9, 2, 7, 1, 6},
    {6, 4, 2, 1, 7, 3, 5, 8, 9}
};
 for (int i = 0; i < 9; i++) {
        for (int j = 0; j < 9; j++) {
            mymap[i][j] = value[i][j];
        }
    }
}
if(wi==4)
{
int value[9][9] = {
    {6, 4, 9, 8, 2, 7, 5, 1, 3},
    {2, 1, 3, 5, 4, 9, 8, 6, 7},
    {8, 7, 5, 1, 3, 6, 9, 4, 2},
    {4, 9, 2, 3, 1, 8, 7, 5, 6},
    {1, 3, 8, 6, 7, 5, 2, 9, 4},
    {7, 5, 6, 4, 9, 2, 1, 3, 8},
    {9, 8, 1, 7, 6, 3, 4, 2, 5},
    {3, 2, 7, 9, 5, 4, 6, 8, 1},
    {5, 6, 4, 2, 8, 1, 3, 7, 9}
};
 for (int i = 0; i < 9; i++) {
        for (int j = 0; j < 9; j++) {
            mymap[i][j] = value[i][j];
        }
    }
}
if(wi==5)
{
int value[9][9] = {
    {3, 7, 5, 8, 1, 6, 9, 4, 2},
    {8, 4, 9, 5, 2, 7, 3, 1, 6},
    {1, 2, 6, 9, 3, 4, 5, 7, 8},
    {5, 9, 3, 1, 7, 8, 6, 2, 4},
    {6, 1, 2, 4, 9, 3, 7, 8, 5},
    {7, 8, 4, 6, 5, 2, 1, 3, 9},
    {9, 5, 7, 2, 4, 1, 8, 6, 3},
    {2, 3, 8, 7, 6, 9, 4, 5, 1},
    {4, 6, 1, 3, 8, 5, 2, 9, 7}
};
 for (int i = 0; i < 9; i++) {
        for (int j = 0; j < 9; j++) {
            mymap[i][j] = value[i][j];
        }
    }
}

if(wi==6)
{
int value[9][9] = {
    {8, 3, 9, 7, 1, 4, 5, 2, 6},
    {6, 7, 1, 5, 8, 2, 4, 9, 3},
    {2, 5, 4, 3, 9, 6, 7, 8, 1},
    {9, 6, 7, 1, 2, 3, 8, 5, 4},
    {4, 1, 3, 8, 5, 7, 2, 6, 9},
    {5, 8, 2, 4, 6, 9, 3, 1, 7},
    {3, 9, 8, 2, 7, 1, 6, 4, 5},
    {7, 2, 6, 9, 4, 5, 1, 3, 8},
    {1, 4, 5, 6, 3, 8, 9, 7, 2}
};
 for (int i = 0; i < 9; i++) {
        for (int j = 0; j < 9; j++) {
            mymap[i][j] = value[i][j];
        }
    }
}

if(wi==7)
{
int value[9][9] = {
    {6, 1, 8, 5, 2, 7, 3, 9, 4},
    {3, 2, 9, 1, 4, 6, 7, 8, 5},
    {4, 5, 7, 9, 8, 3, 2, 6, 1},
    {7, 4, 6, 8, 3, 5, 1, 2, 9},
    {8, 9, 5, 2, 1, 4, 6, 3, 7},
    {1, 3, 2, 6, 7, 9, 4, 5, 8},
    {2, 8, 3, 4, 9, 1, 5, 7, 6},
    {5, 7, 1, 3, 6, 8, 9, 4, 2},
    {9, 6, 4, 7, 5, 2, 8, 1, 3}
};
 for (int i = 0; i < 9; i++) {
        for (int j = 0; j < 9; j++) {
            mymap[i][j] = value[i][j];
        }
    }
}

if(wi==8)
{
int value[9][9] = {
    {4, 9, 1, 6, 5, 7, 8, 3, 2},
    {8, 2, 7, 4, 1, 3, 6, 9, 5},
    {6, 5, 3, 2, 9, 8, 4, 7, 1},
    {5, 4, 9, 8, 2, 1, 7, 6, 3},
    {7, 3, 2, 5, 6, 4, 9, 1, 8},
    {1, 6, 8, 7, 3, 9, 5, 2, 4},
    {9, 7, 5, 3, 8, 2, 1, 4, 6},
    {2, 8, 4, 1, 7, 6, 3, 5, 9},
    {3, 1, 6, 9, 4, 5, 2, 8, 7}
};
 for (int i = 0; i < 9; i++) {
        for (int j = 0; j < 9; j++) {
            mymap[i][j] = value[i][j];
        }
    }
}
     
}
bool Hanidoku::dono()
{
	for(int i =0;i<9;i++)
	{
		for(int j =0;j<9;j++)
		{
			if(mymap[i][j]==0)
			{
				return false;
			}
		}
	}
	return true;
}


bool check_unique(const vector<int>& elements) {
    set<int> seen;
  for (int i = 0; i < elements.size(); i++) {
    int num = elements[i];
    if (num != 0) {
        if (seen.count(num)) return false;
        seen.insert(num);
    }
}
    return true;
}

int  Hanidoku::oioi() {
    // 检查每一行
    int ppp=0;
    int roww[10];
    for (int i = 0; i < 9; i++) {
    	  for(int k = 0;k<10;k++)
    {
    	roww[k]=0;
	}
        for (int j = 0; j < 9; j++) {
            if(mymap[i][j]!=0)
            {
            	if(roww[mymap[i][j]]==0)
            	{
//            		printf("\nj=%d",j); 
            		roww[mymap[i][j]]++;
				}
				else{
//					printf("\nmu=%d\n",mymap[i][j]); 
//						printf("\nmo=%d\n",roww[mymap[i][j]]); 
					ppp=1;
					return ppp;
				}
			}
        }
    }

    // 检查每一列
      int coll[10];
    for (int j = 0; j < 9; j++) {
    	   for(int k = 0;k<10;k++)
    {
    	coll[k]=0;
	}
        for (int i = 0; i < 9; i++) {
                if(mymap[i][j]!=0)
            {
            	if(coll[mymap[i][j]]==0)
            	{
            		coll[mymap[i][j]]++;
				}
				else{
					ppp=2;
					return ppp;
				}
			}
        }
    }
    // 检查每个3x3的小宫
    for (int blockRow = 0; blockRow < 3; blockRow++) {
        for (int blockCol = 0; blockCol < 3; blockCol++) {
            vector<int> block;
            for (int i = 0; i < 3; i++) {
                for (int j = 0; j < 3; j++) {
                    block.push_back(mymap[blockRow * 3 + i][blockCol * 3 + j]);
                }
            }
            if (!check_unique(block))  {
        	ppp=3;
        	return ppp;
		}
        }
    }
    // 检查主对角线
        int col1[10];
    for(int i = 0;i<10;i++)
    {
    	col1[i]=0;
	}
    for (int i = 0; i < 9; i++) {
            if(mymap[i][i]!=0)
            {
            	if(col1[mymap[i][i]]==0)
            	{
//            		printf("\nmu=%d\n",mymap[i][i]); 
            		col1[mymap[i][i]]++;
				}
				else{
					ppp=4;
					return ppp;
				}
			}
    }

    // 检查副对角线
        int col2[10];
    for(int i = 0;i<10;i++)
    {
    	col2[i]=0;
	}
    for (int i = 0; i < 9; i++) {
          if(mymap[i][8-i]!=0)
            {
            	if(col2[mymap[i][8-i]]==0)
            	{
            		col2[mymap[i][8-i]]++;
				}
				else{
					ppp=5;
					return ppp;
				}
			}
    }


    return ppp; // 如果所有检查都通过，返回 true
}
