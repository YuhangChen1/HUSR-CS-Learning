# 实验课

# **实验一：熟悉C程序的运行和调试方法**

```
1.
#include<math.h>  /* 数学函数库的头文件 */
#include<stdio.h>
int main()
{
	long x,y;
	for(int i=1;i<100000;i++) 
	{
	     x=sqrt(i+100);   /* sqrt是求平方根的函数 */ 
		 y=sqrt(i+268);
		if((x*x==i+100)&& (y*y==i+268))
			printf("%d\n",i);
	}
	return 0;
}




2.
 #include<stdio.h>
int main(void)
{
    char c, numchar, numline;
    numchar = 0;
    numline = 0;
    c = getchar();
    while(c != EOF){
        c = getchar();
        numchar++;
        if(c == '\n')
            numline++;
    }
    printf("字符数:%d,", numchar);
    printf("行数:%d", numline);
    return 0;
}





3.
#include<stdio.h>
int main()
{
      int day,month,year,sum,leap,i;
	   int mdays[12]={31,28,31,30,31,30,31,31,30,31,30,31};
		scanf("%d%d%d",&year,&month,&day);
		sum=0;
		for(i=0;i<(month-1);i++)
		{
			sum+=mdays[i];
		}
		sum=sum+day;
		if((year%400==0&&year%100==0)||(year%4==0&&year%100!=0))
			leap=1;
		else
			leap=0;
		if(leap==1&&month>2)
			sum++;
		printf("It is the %dth day.",sum);
		return 0;
	}
	
	
	
	
	
	
	
4.
 int main()
{
   int a =0;
   for(a = 1;a<=1000;a++)
   {
      int sum = 0;
      int y =1;
      for(y = 1;y<a;y++){
         if(a%y==0){
            sum = sum +y;
         }
      }
         if(sum==a){
            printf("%d\n",a);

      }
   }
   return 0;
}








5.
 #include<stdio.h>
 int main()
 {
     int count, max, x, t;
     scanf("%d", &x);
     count =0;
     max = 0;
     while(x!=0)
     {
         t = x % 10;
         if(t == 0)
            count++;
         if(t > max)
            max = t;
         x = x/10;
     }
     printf("该数有%d个零,最大数字是%d\n", count, max);
     return 0;
 }
 
 
 
 
 
 
 
 
 
 
 6.int strLength(char s[]);
int main() 
{
	char s[1000];
	scanf("%s",&s);
	printf("串%s的长度为:%d\n",s,strLength(s));
	strReverse(s);  
	printf("反转后:%s",s);
	return 0;
}

int strLength(char s[])  /* 返回字符串的长度（不含串尾）*/ 
{
	int i=0;
	while(s[i]!=0){
      i++;


   }	
   return i;
}

void strReverse(char s[])  /* 反转串s */
{
	int i,j;
	for(i=0,j=(strLength(s)-1);i<j;i++,j--)  /* 从两头遍历s */
	{
	    char t=0;
		//  t=s[i]; 
	   //  s[j]=s[i]; 
	   //  s[i]=t; 
      // s[j]=t;
      t = s[j];
      s[j]=s[i];
      s[i]=t;


    }
}
```

# **实验二 C语言基本语法元素**

```
1. #include<stdio.h>
#define PI 3.14159
int main(){
	int f;
	short p, k;
	double c, r, s;
	
	/*任务1*/
	printf("Input Fahrenheit:");
	scanf("%d", &f);
	c=5.0/9.0*(f-32)*1.0;
	printf("\n %d(F)=%.2f(C)\n\n",f,c);
	/*任务2*/
	printf("input the radius r:");
	scanf("%lf",&r);
	s = PI * r * r*1.0;
	printf("\nThe acreage is %.2f\n\n", s);
	/*任务3*/
	k=0xa1b2;
     p=0x8423;
    int newint=p&0xff00|k>>8&0x00ff;

	printf("new int = %x\n\n",newint);
	return 0;  
}



2. #include<stdio.h>
int main()
{
   int n;
   scanf("%d",&n);
   int t =n;
   int cnt = 0;
   int sum = 0;
   while(n!=0){
      cnt ++;
      sum += (n%10);
       n = n/10;



   }
   printf("%d是%d位数，且各位数字之和为%d。",t,cnt,sum);
}


3.  #include<stdio.h>
 int main()
 {  int n;
    int count=0; 
    scanf("%d",&n);
    char sale[n];
    for(int i=0;i<=(n-1);i++)
    scanf("%d",&sale[i]);
    for(int i=1;i<=(n-2);i++)
    if(((sale[i-1]<sale[i])&&(sale[i]>sale[i+1] ))||((sale[i-1]>sale[i])&&(sale[i]<sale[i+1] )))
    count++;
   printf("%d",count);
   return  0;
 }
 
 
 4. #include<stdio.h>
#include<stdlib.h>
#include<string.h>
int judge(char ch[])
{
	for (int i = 0; i < strlen(ch); i++)
	{
		if (ch[i] < '0' || ch[i]>'9')
			return 1;
	}
	return 0;
}

int main()
{
	char ch[20];
	while (scanf("%s", ch) != EOF)
	{
		if (strlen(ch) != 11)
			printf("长度不合法");
		else if (judge(ch))
			printf("字符串中存在非数字字符");
		else if (ch[0] != '1')
			printf("第1位不合法");
		else if (ch[1] != '3' && ch[1] != '4' && ch[1] != '5' && ch[1] != '7' && ch[1] != '8')
			printf("第2位不合法");
	}
	return 0;
}



5.#include<stdio.h>
int main()
{
    unsigned short x,m,n;
    scanf("%hx",&x);
    scanf("%hu%hu",&m,&n);
    unsigned short result = (x>>m)<<(16-n);
    printf("%x",result);
    return 0;

}



6. #include<stdio.h>

 int main()
{
	unsigned int n;
	unsigned int ch[4];
	while (scanf("%u", &n) != EOF)
	{
		ch[0] = n >> 24;
		ch[1] = n << 8 >> 24;
		ch[2] = n << 16 >> 24;
		ch[3] = n << 24 >> 24;
		printf("%u.%u.%u.%u\n", ch[0], ch[1], ch[2], ch[3]);
	}
	return 0;
}



7. int main()
{
	int k;
	char ch[81];
	gets(ch);
	scanf("%d", &k);;
	for (int i = 0; i < strlen(ch); i++)
	{
		if (ch[i] >= 'A' && ch[i]+ k - 1 <= 'Z')
			ch[i] += k - 1;
		else if(ch[i] <= 'Z' && ch[i] + k - 1 > 'Z')
			ch[i] = ch[i] + k - 2 - 'Z'+'A';
	}
	for (int i = 0; i < strlen(ch)-1; i+=2)
	{
		char temp = ch[i];
		ch[i] = ch[i+1];
		ch[i+1] = temp;
	}
	printf("%s", ch);
	return 0;
}



8. #include<stdio.h>
 int main()
{
	char a;
	char pre=0;
	int i = 0, j = 0, k = 0;
	int m = 0, n = 0;
	while (a = getchar(), a != EOF)
	{
		if (a < 0)
		{
			n++;
			m++;
		}
		if (a == '\n')
			k++;
		if ((a >= 'a' && a <= 'z') || (a >= 'A' && a <= 'Z'))
		{
			do {
				j++;
				a = getchar();
			} while (a != ' '&&a!='\n');
			i++;
			if (a == '\n')
			{
                k++;
			 }
		}
	}
	printf("字数 %d\n", i+m/3);
	printf("字符数 %d\n", j+n/3);
	printf("行数 %d\n", k);
	return 0;
}




9. #include<stdio.h>
#include<stdlib.h>
#include<malloc.h>
#include<string.h>
#include<math.h>

#include<time.h>
 int ext(char p,int i)
{
	int n = p / (int)pow(2, i) % 2;
	return n;
}

char jiami(char p)
{
	char q=0;
	int ch[6];
	for (int i = 0; i < 6; i+=2)
	{
		 ch[i+1] = ext(p, i);
		 ch[i] = ext(p, i + 1);
	}
	int n = ext(p, 6) + 2 * ext(p, 7);
	int arr[8];
	for (int i = 0; i < 6; i++)
	{
		arr[(i + n) % 6] = ch[i];
	}
	arr[6] = ext(p, 6);
	arr[7] = ext(p, 7);
	for (int i = 0; i < 8; i++){
		q += arr[i] * pow(2, i);
	}
	
	return q;
}

int main()
{
	char ch[20];
	scanf("%s", ch);
	for (int i = 0; i < strlen(ch); i++)
	{
		ch[i] = jiami(ch[i]);
	}
	printf("%s", ch);
	return 0;
}
```

# **实验三 流程控制**

```
1.#include<stdio.h>
int main()
{
	int i,x,k,flag=0;
//	printf("本程序判断合数，请输入大于1的整数，以Ctrl+Z结束\n");
	while(scanf("%d",&x)!=EOF){
        if(x==2){
            break;
        }
		for(i=2,k=x,k>1; i<k; i++){
			if(!(x%i)){
				flag=1;
				break;
			}
	}
    if(flag==1) {
        printf("%d是合数",x);
        }
		else {
        printf("%d不是合数",x);
        } 
    }
	return 0;
}

2.#include<stdio.h>
int main()
{
	int i,x,k,flag=0;
//	printf("本程序判断合数，请输入大于1的整数，以Ctrl+Z结束\n");
	while(scanf("%d",&x)!=EOF){
		for(i=2,k=x,k>1; (i<k)&&(flag==0); i++)
			if(!(x%i)){
				flag=1;
			}
            if(x==2)  flag=0;
		if(flag==1) printf("%d是合数",x);
		else printf("%d不是合数",x); 
	}
	return 0;
}

3.#include<stdio.h>
int main()
{
	int i=2,x,k,flag=0;
//	printf("本程序判断合数，请输入大于1的整数，以Ctrl+Z结束\n");
	while(scanf("%d",&x)!=EOF){
        k=x;
		do{
            if(x%i==0){
				flag=1;
				//break;
		
			}
            i++;
	    } while(i<k);
		if(flag==1) printf("%d是合数",x);
		else printf("%d不是合数",x); 
	}
	return 0;
}

4.#include<stdio.h>
#include<math.h>
int main()
{
	int n,i,tishen,j,niu,flag;
    scanf("%d",&n);
    i=pow(10,n-1);
    for(i=pow(10,n-1);i<pow(10,n);i++)
    {   
        flag=1;
        tishen=i;
        for(tishen=i;tishen>0;tishen=tishen/10)
        {
            niu=1;
            for(j=2;j<tishen;j++)
            {
                if(tishen%j==0)
                {
			    niu=0;
                break;	}
            }
            if(niu==1)
            {
                flag=0;
                break;
            }
            
            
        }
        if(flag==1)
        printf("%d ",i); 
    }
    return 0;
    

}

5.#include<stdio.h>
int main()
{
	int n;
    scanf("%d",&n);
    int k = n;
    int m =0;
    if(n<1000){
      m=0;
    }
    if(n>=1000&&n<=2000){
        m = (n-1000)*0.05;
    }
     if(n>2000&&n<=3000){
        m = 1000*0.05+(n-2000)*0.1;
    }
    if(n>3000&&n<=4000){
        m = 1000*0.05+1000*0.1+(n-3000)*0.15;
    }
    if(n>4000&&n<=5000){
        m = 1000*0.05+1000*0.1+1000*0.15+(n-4000)*0.20;
    }
    if(n>5000){
        m = 1000*0.05+1000*0.1+1000*0.15+1000*0.20+(n-5000)*0.25;
    }
    printf("%d",m);
    return 0;
}


6.#include<stdio.h>
#include<math.h>
int main()
{
	int n; 
   int start,last;
	scanf("%d",&n);
	start=pow(10,n-1);
	last=pow(10,n);
	for(int k=start;k<last;k++)
	{
		int p=k*k;
      int sum=0;
	/*	for(int u=1;u<=n;u++)
		{
			int chuyu=p%pow(10,u);
			
		}*/
		sum=p%last;
		if(sum==k)
		printf("%d ",k);
	}
	return 0;
}

7.#include<stdio.h>
#include<math.h>
int main()
{
    int n;
    scanf("%d",&n);
    int array[n];
    for(int i =0;i<n;i++){
        scanf("%d",&array[i]);
    }
    int max = 0;
     for(int i =1;i<n;i++){
         if((abs(array[i]-array[i-1]))>=max){
             max = abs(array[i]-array[i-1]);
         }
     }
     printf("%d",max);
     return 0;

}

8.#include<stdio.h>
int main()
{
	char c;int flag=0;int b=0;
again:	while((c=getchar())!=EOF)
	{
		if(c==' ' && flag==0)
		{
			flag=1;
			goto again;
		}
		if(c==' ' && flag==1){
			continue;
		}
		if(c!=' ' && flag==1)
		{
			putchar(' ');
		//	putchar(c);
			flag=0;
		}
		if(c!=' ' && flag==0)
		{
			putchar(c);
		}
        if(c=='\n')
         b=1;
		
	}
   if(b) putchar(' ');
}

9.#include<stdio.h>
int main()
{
    int n;
    scanf("%d",&n);
    n +=1;
    int k=0,i=0;
    int a[15][15];
    for(k=0;k<=n;k++)
	{
		for( i=0;i<=k+1;i++)  
		{
			a [k][i]=0;
		}
	}
    a[0][0]=1;
    for(int b=0;b<2*(n-1);b++){
				printf(" ");
                }
    printf("%d   \n",a[0][0]);
    int l,v;
	for( l=1;l<n;l++){
		for(int b=0;b<2*(n-l-1);b++)
        {
			printf(" ");
        }
        //我们假定i为行而j表示某一行的第j-1个数，从0开始
    for(v =0;v<=l;v++){
        if(v==0){
            a[l][v]=1;
        }
        else{
            a[l][v]=a[l-1][v]+a[l-1][v-1];
        }
        if(a[l][v])	printf("%-4d",a[l][v]);
    }
    //if(!(i==n && j==n) ) {
			printf("\n");
            //}
}
return 0;
}

10.#include<stdio.h>
#include<math.h>
int main()
{
    int count=2,n=2,flag=1;
    int k=pow(2,n);
    long m;
    scanf("%ld",&m);
    for( ; k-1<=m;n++)
    {
    	flag=1;
        int i=pow(2,n)-1;
        for(int p=2;p<i/2;p++)
        {
            if(i%p==0)
            {
                flag=0;
                break;
            }
            
        }
        if(flag==1){
             printf("M(%d)=%d\n",count,i);
        }
        count++;
        k=pow(2,count);
    }

}


11.#include<stdio.h>
// 	long m;
// 	scanf("%ld",&m);
// 	int arr[1000000];
//     //这里我们用l筛法
	
// 	for(long k=2;k<=m;k++ )
// 	{
// 		arr[k]=1;
// 	}
// 	for(long k=2;k<=m;k++)
// 	{
// 		if(arr[k])
// 		{   
// 			for(long a=2*k;a<=m;a+=k)
// 			{
// 				arr[a]=0;
// 			}
// 		}
// 	}
// 	#include<stdio.h>
int main()
{
	long m;
	scanf("%ld",&m);
	int arr[1000000];
    
	
	for(long k=2;k<=m;k++ )
	{
		arr[k]=1;
	}
	for(long k=2;k<=m;k++)
	{
		if(arr[k])
		{   
			for(long a=2*k;a<=m;a+=k)
			{
				arr[a]=0;
			}
		}
	}
	for(long k=2;k+2<=m;k++)
	{
		if(arr[k] && arr[k+2]) 
		printf("(%d,%d) ",k,k+2);	
	}
return 0;
}
			
		
// 	}
	
// }
//     long m;
//     scanf("%ld",&m);
//     int arr[100000];//我们用下标表示数,注意不是下标，看后面那一句体会一下
//     for(long i =2;i<1000000;i++){
//         arr[i]=1;
//     }
//     for(long k =2;k<1000000;k++){
//         if(arr[k]){
//             for(long a = 2*k;a<100000;a+=k){
//                 arr[a]=0;
//             }
//         }
//     }

// }


12.
// #include<stdio.h>
// int main()
// {
//     long int n = 12345;
//     int x;

//     scanf("%d",&x);
//     long int m;
//     int arr[10]={0};
//     for (;n<=98765;n++){
//         int flag = 1;
//         if(n%x==0){
//             m = n/x;
//             // for(int i = 0;i<=9;i++){
//             //     arr[i]=0;//初始化数组
//             // }
//             for (int i1 = 4;i1>=0;i1--){
//                 arr[i1]=n%10;
//                 n = n/10;
//                 //printf("%d",arr[i1]);
//             }
//             for(int i2 = 9;i2>=5;i2--){
//                 arr[i2]=m%10;
//                 m = m/10;
//                 //printf("%d",arr[i2]);
//             }
//             //int flag = 1;
//             for (int con = 9;con>=0;con--){
//                 int com = 0;
//                 for(;com<con;com++){
//                     if(arr[com]==arr[con]){
//                         flag=0;
//                         break;
//                     }
//                 }
//                 if(flag==0){
//                 break;
//                 }
//             }
//             if(flag==1)                        //打印 
//          {             for(int g=0;g<=4;g++){
//                  printf("%d",arr[g]);     }        
//                  printf("/");
//              for( int l=5;l<=9;l++){
//                  printf("%d",arr[l]);}
//             printf("=%d\n",x);
//          }    
//         }
//         // if(flag==1)                        //打印 
//         //  {             for(int g=0;g<=4;g++){
//         //          printf("%d",arr[g]);     }        
//         //          printf("/");
//         //      for( int l=5;l<=9;l++){
//         //          printf("%d",arr[l]);}
//         //     printf("=%d\n",n);
//         //  }    
//     }
//     return 0;
// }


#include <stdio.h>
  
int main()
 {
      int n,x,y,temp;//a[10]={0};
     int i,j,flag;
     scanf("%d",&n);
      for(x=12345;x<=98765;x++)
      {
         int a[10]={0};
         flag = 1;
         temp = x;
         
     //    if(x%n != 0)                    //不用这句数组a要重新全部初始化！ 
     //        continue;
    
         if(x%n== 0)                        //记录y的各个位 
         {
         
             y = x/n;
             for(i=4;i>=0;i--)
             {
                 a[i] = y%10;
                 y = y/10;
             }
         }
         
         for(i=9;i>=5;i--)                //记录x的各个位 
         {
             a[i] = temp%10;
             temp = temp/10;
             
         }
         
         for(i=0;i<9;i++)                //判断有没有重复的 
        {
             for(j=i+1;j<=9;j++)
            {
                 if(a[i] == a[j])
                 {
                     flag = 0;
                    break;
                 }
             }
             if(flag ==0)
                 break;
         }
        
        if(flag==1)                        //打印 
         {             for(i=5;i<=9;i++)
                 printf("%d",a[i]);             printf("/");
             for(i=0;i<5;i++)
                 printf("%d",a[i]);
            printf("=%d\n",n);
         }    
     }
     return 0;
 }
```

# 实验四 函数和预处理

```
1
#include<stdio.h>
long x =0;
long y =0;
long fab (int n){
    if(n==0){
        return x;
    }
    else if(n==1){
        return y;
    }
    else{
         long temp = x;
    x = y;
    y += temp;
    return fab(n - 1);
    }
    
   
}

int main()
{
    long n, sum = 0;
    scanf("%ld", &n);
    for (int i = 1; i <= n; i++)
    {
        x = 0;
        y = 1;
        sum += fab(i);
    }
    printf("%ld", sum);
    return 0;
}



2
/******************  begin *********************/
#include<stdio.h>
#include<assert.h>
#define py 3.14159

int main()
{
    double n;
    scanf("%lf",&n);
     assert(n);
     double a=py*n*n;
     int b=py*n*n;
     double c; c=a-b;
     if(c>=0.5)  b+=1; 
        printf("The integer fraction of area is %d",b);

 
}



/******************   end  *********************/


3.

#include<stdio.h>
long sum_fac(int n);
int main(void)
{
	int k;
	for(k=1; k<=20; k++)
		printf("k=%d the sum is %ld\n",k,sum_fac(k));
	return 0;
}
long sum_fac(int n){
	static long s=0;
	int i; long  fac=1;
	for(i=1;i<=n;i++) fac*=i;
	s+=fac;
	return s;
}

4
#include<stdio.h>
long long sum_fac(int n)
{
    long long int sum = 0,fac = 1;
    if(n==1){
        return 1;
    }
    else{
	for(int i =1;i<=n;i++){
          fac *= i;
    }
    sum +=fac;
   }
    return sum_fac(n-1)+sum;
}
int main(void)
{
	int k;
	for(k=1; k<=20; k++)
		printf("k=%d the sum is %lld\n",k,sum_fac(k));
	return 0;
}

5
#include<stdio.h>
double mulx(double x,int n);
long fac(int n);

double sum(double x,int n)
{
    double s=0;
    if(n==1){
        return 1+x;
    }
    else{
        s = mulx(x,n)/fac(n);
    }
    return s+sum(x,n-1);
}

double mulx(double x,int n)
{
	int i;
	double z=1.0;
	for(i=0;i<n;i++)
	{
		z=z*x;
	}
	return z;
}

long fac(int n)
{
	long fac1 = 1;
    for(int i =1;i<=n;i++){
          fac1 *=i;
    }
    return fac1;
}

int main()
{
	double x;
	int n;
	scanf("%lf%d",&x,&n);
	printf("The result is %lf",sum(x,n));
	return 0;
} 




6.
// #include<stdio.h>
// void goldbach(int n)
// //请完成goldbach函数，将大于等于4的偶数n表示成两个素数的和。
// {
// /**********   Begin   **********/
// int flag1 ;
// int flag2 ;
// int m;
// int i;
// int p;
// if(n==4){
//     printf("4=2+2");
// }
// for (i =3;i<n ; i++){
//     for (int k =2;k<i;k++){
//         flag1 = 1;
//         if(i % k==0){
//             flag1 = 0;
//             break;
//         }
//     }
//     if(flag1==1){
//         p = n-i;
//         for (int u =2;u<p;u++){
//             flag2 = 1;
//             if(p % u==0){
//                 flag2=0;
//                 break;
//             }
//         }
//         if (flag2==1){
//             break;
//         }
//     }
//     }
//     printf("%d=%d+%d",n,i,p);
// }

//上面这个代码总是有一个测试集过不了，合理猜测是不是要我把质数判断单独领出来

#include <stdio.h>

int isPrime(int n)
{
    int k = 1, limt;
    if (n == 2)
        return 1;
    if (!(n % 2) || n == 1)
        return 0;
    limt = n / 2;
    for (k = 3; k <= limt; k += 2)
        if (!(n % k))
            return 0;
    return 1;
}

void goldbach(int n)
//请完成goldbach函数，将大于等于4的偶数n表示成两个素数的和。
{
    /**********   Begin   **********/
    int temp, max = 0;
    if (n == 4)
    {
        printf("4=2+2");
    }
    else
    {
        for (int i = 2; i <= n / 2; i++)
        {
            if (isPrime(i) && isPrime(n - i))
            {
                printf("%d=%d+%d", n, i, n - i);
                return;
            }
        }
    }
    /**********    End    **********/
}


/**********    End    **********/








7.

#include<stdio.h>
void isPerfect(int n)
//请完成isPerfect函数，判断整数n是否为完全数
{
/**********   Begin   **********/
int flag ;
int sum = 0;
for (int i=1;i<n;i++ ){
    flag=0;
    if(n%i==0){
        flag = 1;
    }
    if(flag==1){
        sum +=i;
    }
}
if(sum!=n){
    printf("%d is not a perfect number",n);
}
if(sum==n){
    int a[50]={0};
    int cnt =0;
    for(int k=1;k<n;k++){
        if(n%k==0){
            a[cnt]=k;
            cnt ++;
        }
    }
    int cnt2 ;
    printf("%d=1",n);
    for(cnt2=1;cnt2<cnt;cnt2++){
        printf("+%d",a[cnt2]);
    }
    
}


/**********    End    **********/
}








8.
/***定义两个带参数的宏,用于计算三角形面积***/
#include<stdio.h>
#include<math.h>
#define area(s,a,b,c)  (s*(s-a)*(s-b)*(s-c))
#define s(a,b,c) (a+b+c)/2
int main(void)
{
   int a,b,c;
   scanf("%d%d%d",&a,&b,&c);
   float area,s;
   s=s(a,b,c);
   area=area(s,a,b,c);
   printf("%.2f",sqrt((double)(area)));

}






9.
#include<stdio.h>
#define CHANGE 1


int main(void)
{
    char a[100]; gets(a);
     # if CHANGE
        int b=0;
        while(a[b]!='\0')
        {
            if(a[b]>='a' && a[b]<='z')
            {
                a[b]-=32;
            }
            else if(a[b]>='A' &&a[b]<='Z')
            {
                a[b]+=32;
            }

            b+=1;
        }
        printf("%s",a);
    #else printf("%s",a);
    #endif
     
        return 0;
}


10.#define CHANGE 0
#include<stdio.h>

int main(void)
{
    int a[1000];
    gets(a);
    int b=0;
    #if CHANGE
    while(a[b]!='\0'){
        if(a[b]>='a'&&a[b]<='z'){
        a[b] -= 32;
    }
        if(a[b]>='A'&&a[b]<='Z'){
            a[b] +=32;
        }
        b++;
    }
    printf("%s",a);
    #else 
    printf("%s",a);
    #endif
    return 0;

}








11.
第一个文件：
#include<stdio.h>
int x,y;
char ch;
int main(void)
{
	x=10;
   y=20;
   ch=getchar();
   printf("in file1 x=%d,y=%d,ch is %c\n",x,y,ch);
	func1();
	return 0;
}


第二个文件
void func1(void)
{
	extern x;
	extern y;
    extern ch;
    x++;
    y++;
	ch++;
	printf("in file2 x=%d,y=%d,ch is %c\n",x,y,ch);
}

第三个文件
#include<stdio.h>
#include<file2.c>
#include<file1.c>




```

# 实验五 数组

```
1.
//
// #include<stdio.h>
// void strncate(char t[],char s[])
// {
//     int i=0,m=0;
//     while(t[i]!='\0'){
//         i++;
//     }
//     while(s[m]!='\0'){
//         t[i]=s[m];
//         i++;
//         m++;
//     }
//     t[i]='\0';
//     printf("%s\n",t);
// }
// void strdelc(char s[],char c){
//     int j;
//     int k;
//     for(j=k=0;s[j]!='\0';j++){
//         if(s[j]!=c){
//             s[k]=s[j];
//             k++;
//         }
//     }
//     s[k]='\0';
//     printf("%s",s);
// }
// int main()
// {
//     char a [1000];
//     char b [1000];
//     char c;
//     gets(a);
//     gets(b);
//     scanf("%d",&c);
//     strncate(a,b);	
//    // printf("%s\n",b);
// 	strdelc(a,c);	
//     //printf("%s\n",b);
// 	return 0; 
// }
//为什么删除的函数错了？
#include<stdio.h>
void str(char t[],char s[]){
	int i=0,j=0;
	while(t[i]!='\0')
    {
		i++;
	}
	while(s[j]!='\0')
    {
		t[i]=s[j];
        i++; j++;
	}
    s[i]='\0';
    printf("%s\n",t);
}
void stc(char s[],char c){
	int j,k; 
	for(j=k=0;s[j]!='\0';j++)
	{
		if(s[j]!=c)
		{
			s[k++]=s[j];
		}
	}
	s[k] ='\0';
	printf("%s",s);
}
int main(){
	char a[10000],b[10000];
	char c;
    gets(a);
    gets(b);
	scanf("%c",&c);
	str(a,b);	
   // printf("%s\n",b);
	stc(a,c);	
    //printf("%s\n",b);
	return 0; 
}


2
#include<stdio.h>
#include<string.h>
void RemoveDuplicate(char *s);
int main()
{
	char str[200];
   while(fgets(str, 200, stdin) != NULL)
   {
   		RemoveDuplicate(str);
      printf("%s", str);
   }
   return 0;
}

void RemoveDuplicate(char *s)
{
	int r, w, i, len;
   len = strlen(s);
   for (r = w = 0; r < len; r++)
   {
   		if(s[r]!='\0')
      {
      		s[w++] = s[r];
         for (i = r + 1; i < len; i++)
         {
         	if(s[r]==s[i])
            	s[i] = '\0';
         }
      }
    
   }  s[w]='\0' ;
}



3.
// #include<stdio.h>
// #include<string.h>
// void RemoveDuplicate(char *s);
// int main()
// {
// 	char str[200];
//    while(fgets(str, 200, stdin) != NULL)
//    {
//    		RemoveDuplicate(str);
//       printf("%s", str);
//    }
//    return 0;
// }

// void RemoveDuplicate(char *s){
//     int  len,a,k;
//    len = strlen(s);
//    int str [256]={0};
//   for(int i = 0;i<len;i++){
//      if(s[i]!='\0'){
//         a = s[i];
//         if(str[a]==0){
//            str[a]=1;
//            s[k]=s[i];
//            k++;
//         }
//         else{
//            s[i]='\0';
//         }
//      }
//   }
//    s[k]='\0';
// }

//你告诉我为什么这里没有输出啊！！！！！！！！！


#include<stdio.h>
#include<string.h>
void removeDuuplicate(char *s);
int main()
{
	char a[100];
	gets(a);
	removeDuuplicate(a);
	puts(a);	
}




void removeDuuplicate(char *s)
{
    int  len;int r,k;
    len = strlen(s);  int str[257]={0};
    for ( r = 0,k=0; r < len; r++)
    {
        if(s[r])
        {
            int a=s[r];
            if(!(str[a]))
            {
                s[k++]=s[r];
                str[a]=1;
            }
            else{
                s[r]='\0';
            }
        }
        
    }
    s[k]='\0';
    
}

4.# include<stdio.h>
int main(void)
{
	int a[100], b[100];
   int i, j, k,M,N;
   scanf("%d%d", &M, &N);
   for (i=0; i<M;i++){
   	a[i]=i+1;//一共有多少人，每个人的序号 第0对于第1,M表示参加游戏的人数
   }
   for (i=M,j=0; i>1; i--)//j表示选出去的人，N表示你喊的数
   {
   		for (k=1; k<=N; k++)//第一个喊的是一
           {
            j++;//喊一个加一个
   			if(j>i-1){ 
                   j=0;//喊完一论重置
               }
           }
    	b[M-i]=  (j? a[j-1]:a[i-1]) ;//如果是0，到头输出i-1
    	if(j)
        for(k=--j; k<i; k++)//缩减数组,把每次寄的人排出去
        a [k]=a[k+1];    ;
   }
   for(i=0; i<M-1; i++){
   	printf("%6d", b[i]);}
   printf("\n%6d\n", a[0]);
   return 0;
}


5.
// #include <stdio.h>//标记元素是指用数组单位的内容进行标记
// #define N 4
// #define M 20000
// int circle[N]= {0};//0表示这个人在圈内，1表示在圈外
// void text (int n,int m,int pos){
//     int cnt;
//     if(n==-1){
//         return ;//剩下一个人结束递归
//     }
//     for (cnt =1;cnt <= m;pos++){//1到m报数
//         pos = pos %N;//环状处理
//         if(circle[pos]==0){
//             cnt ++;//在圈内报数
//         }
//     }
//     circle[pos-1]=1;//报M的人走鬼
//     text(n-1,m,pos);//递归到下一轮
// }
//  int main(){
//      int i;
//      text (N,M,0);
//    for(i=0;circle[i];i++){
//        printf("%d",i+1);
//     }
//     return 0;
//  }


// #include<stdio.h>
// int main(){
// int m,n,k=1,j=0;//m人数，n表示要寄的人数，k是报数,j表
//  scanf("%d%d",&m,&n);
// int circle [m];
// for (int i=0;i<m;i++){
//        circle [i]=i+1;
// }
// for(int i = m;m>1;i--){
//     while(k<=n){
//         if(circle[j]!=0){
//             j++;
//             if(j>m){
//                 j=0;
//                 continue;
//             }
//             k++;
//         }
//         else{
//             j ++;
//             if(j>m){
//                 j=0;
//             }
//         }
//     }
//     circle[j-1]=0;
//     k = 1;
// }
// for(int l=0;l<m;l++)
//    {
//    	if(circle[l]!=0) {printf("%d\n",circle[l]);}
//    }
//    return 0;
// }



# include<stdio.h>
int main(void)
{
   int M,N;
   scanf("%d %d",&M,&N);
   int c[M];
   int i, j=0, k=1;
   for (i=0; i<M;i++)
   	{
	   c[i]=1+i;
    }
   for (i=M;i>1; i--)
   {
   		while(k<=N)
   			{
                   if(c[j]!=0) 
                   {
                       j++;
                       if(j>M) 
					   {
					   	j=0;
					   	continue;
					   }
                       k++;
                   }
                   else 
				   {
                   	j++;
                    if(j>M) j=0;
				   }
            }
        c[j-1]=0;
        k=1;
   }    
   for(int l=0;l<M;l++)
   {
   	if(c[l]!=0) printf("%d\n",c[l]);
   }
   return 0;
}



6.#include<stdio.h>
int main(){
    int m;
     scanf("%d",&m);
     int arr[32]={0};
     int n =m;
     int i =31;
     if(m>=0){
     while (n!=0){
         arr[i]=n%2;
         n = n/2;
         i--;
     }
     for (int l =0,cnt=1;l<32;l++,cnt++){
         printf("%d",arr[l]);
         if(cnt%4==0){
            printf(" ");
         }
             }
     }
     if(m<0){
        for(int y =0;y<32;y++){
        arr[y]=1;
        }
        int t= -1-(m);
        int p =31;
        int text [31]={0};
         while (t!=0){
         text[p]=t%2;
         t = t/2;
         p--;
     }
     for (int u = 0;u<32;u++){
        if(text[u]==1){
            arr[u]=0;
        }
     }
     for (int l =0,cnt=1;l<32;l++,cnt++){
         printf("%d",arr[l]);
         if(cnt%4==0){
            printf(" ");
         }
             }
     }
     return 0;
}


7.#include<stdio.h>
#include<string.h>
#define max 100
void output( char name[][max],int point[],int number)
{
	for(int k=0;k<number;k++)
    {
        printf("%s %d\n",name[k],point[k]);
    }
}
void sort( char name[][max],int point[],int number)
{
		for(int k=0;k<number;k++)//使用冒泡排序
        {
            for(int i=number-1;i>0;i--){
            if(point[i]>point[i-1]){
                int  temp1;            
				temp1=point[i-1 ];     
				point[i-1]=point[i];   
				point[i]=temp1;
                char temp2[max];
				memcpy(temp2,name[i],max );
				memcpy(name[i],name[i-1],max );
				memcpy(name[i-1],temp2, max );//使用memcpy函数交换字符串
            }
            if(point[i]==point[i-1])
			{
				int a;
				a= strcmp(name[i],name[i-1]);
				if(a<0)
				{
					int  temp1;            
				temp1=point[i-1 ];     
				point[i-1]=point[i];   
				point[i]=temp1; 
				char temp2[max];
				memcpy(temp2,name[i],max );
				memcpy(name[i],name[i-1],max );
				memcpy(name[i-1],temp2, max );//同理如上
				}
				
						}			
            }
        }
}
int main()
{
    int order;
    scanf("%d",&order);
    int number;
    scanf("%d",&number);
    
    char name[number][max]; int point[max];

    for(int k=0;k<number;k++)
    {
        scanf("%s %d",name[k],&point[k]);  //name[k]为地址 
        //getchar();
    }	
	
    scanf("%d",&order);
	if(order==2) 
	{
		sort(name,point,number);
		scanf("%d",&order);
	}
	
    if(order==3) 
	{
		output(name,point,number);
		scanf("%d",&order);
	}
	if(order==0)  return 0;
    
    
}



8.#include<stdio.h>
#include<string.h>
#define max 100
void output( char name[][max],int point[],int number)
{
	for(int k=0;k<number;k++)
    {
        printf("%s %d\n",name[k],point[k]);
    }
}
void sort( char name[][max],int point[],int number)
{
		for(int k=0;k<number;k++)//使用冒泡排序
        {
            for(int i=number-1;i>0;i--){
            if(point[i]>point[i-1]){
                int  temp1;            
				temp1=point[i-1 ];     
				point[i-1]=point[i];   
				point[i]=temp1;
                char temp2[max];
				memcpy(temp2,name[i],max );
				memcpy(name[i],name[i-1],max );
				memcpy(name[i-1],temp2, max );//使用memcpy函数交换字符串
            }
            if(point[i]==point[i-1])
			{
				int a;
				a= strcmp(name[i],name[i-1]);
				if(a<0)
				{
					int  temp1;            
				temp1=point[i-1 ];     
				point[i-1]=point[i];   
				point[i]=temp1; 
				char temp2[max];
				memcpy(temp2,name[i],max );
				memcpy(name[i],name[i-1],max );
				memcpy(name[i-1],temp2, max );//同理如上
				}
				
						}			
            }
        }
}
void seek(char name[][max],int point[],int number,int point1)
{
    int t = 0;
    for(int k = 0;k<number;k++){
        if(point[k]==point1){
            printf("%s %d\n",name[k],point[k]);
            t++;
        }
    }
    if(!t){
        printf("not found");
    }
}
int main()
{
    int order;
    scanf("%d",&order);
    int number;
    scanf("%d",&number);
    
    char name[number][max]; int point[max];

    for(int k=0;k<number;k++)
    {
        scanf("%s %d",name[k],&point[k]);  //name[k]为地址 
        //getchar();
    }	
	
    scanf("%d",&order);
	if(order==2) 
	{
		sort(name,point,number);
		scanf("%d",&order);
	}
	
    if(order==3) 
	{
		output(name,point,number);
		scanf("%d",&order);
	}
	if(order==0)  return 0;
    if(order==4){
      scanf("%d",&order);
        seek(name,point,number,order);
    }
    
}



9.# include <stdio.h>
# include<string.h>
void strnins(char t [],char s[],int n)
{
    int lenth = strlen(s);
    int lenth2 = strlen(t);
    char exe [100];
    for (int i = 0;i<n;i++){
           exe [i] = t [i];
    }
    for(int i = 0;i<lenth;i++)
    {
        exe [i+n]=s[i];
    }
    for(int i =lenth+n;i<(lenth+lenth2);i++){
        exe [i] = t [n];
        n ++;
    }
    exe [(lenth+lenth2)] = '\0';
    printf("%s",exe);
}//dd
int main()
{
    int n;
    char t_arr [100];
    char s_arr [100];
    scanf("%s",t_arr);
    scanf("%s",s_arr);
    scanf("%d",&n);
    strnins(t_arr,s_arr,n);
    return 0;
}


10.# include <stdio.h>
int main()
{
int x,y;
scanf("%d%d",&x,&y);
int puzzle [x][y];
int puzzle2 [x][y];
//int flag1 = 0;
//int flag2 = 0;
    for (int i =0;i<x;i++){
        for(int j =0;j<y;j++){
            scanf("%d",&puzzle[i][j]);//读入方阵
        }
    }
	for (int i = 0;i<x;i++){
		for(int j =0;j<y;j++){
           puzzle2[i][j] = puzzle[i][j];
		}
	}
for(int i = 0;i<x;i++){
    for(int j = 0,flag1=0;j<y-1;j++){
        if(puzzle[i][j]==puzzle[i][j+1])
        {
            flag1++;
			if(j==y-2&&flag1>=2){
			j++;
			for(int u = flag1;u>=0;u--){
				puzzle[i][j-u]=0;
			}
			flag1 = 0;
		}
        }
		
		else if(flag1>=2 && puzzle[i][j]!=puzzle[i][j+1])
			{
				for(int r=flag1;r>=0;r--)
				{
					puzzle[i][j-r]=0;
				}
				flag1=0;
			}
		else if (flag1>=2&&puzzle[i][j]==puzzle[i][j+1]){
			 flag1 ++;
		}
		else if (flag1<2&&puzzle[i][j]!=puzzle[i][j+1]){
			 flag1 = 0;
		}
    }//tt
}

for(int j = 0;j<y;j++){
    for(int i = 0,flag2=0;i<x-1;i++){
        if(puzzle2[i][j]==puzzle2[i+1][j])
        {
            flag2++;
			if(i==x-2&&flag2>=2){
			i++;
			for(int u = flag2;u>=0;u--){
				puzzle2[i-u][j]=0;
			}
			flag2 = 0;
		}
        }
		// if(i==x-2&&flag2>=2){
		// 	i++;
		// 	for(int u = flag2;u>=0;u--){
		// 		puzzle2[i-u][j]=0;
		// 	}
		// 	flag2 = 0;
		// }
		else if(flag2>=2 && puzzle2[i][j]!=puzzle2[i+1][j])
			{
				for(int r=flag2;r>=0;r--)
				{
					puzzle2[i-r][j]=0;
				}
				flag2=0;
			}
		else if (flag2>=2&&puzzle2[i][j]==puzzle2[i+1][j]){
			 flag2 ++;
		}
		else if (flag2<2&&puzzle2[i][j]!=puzzle2[i+1][j]){
			 flag2 = 0;
		}
    }//tt
}
for(int k=0;k<x;k++)
    {
        for(int i=0;i<y ;i++)
        {   if(i!=0)  printf(" ");
        	if(puzzle[k][i] && puzzle2[k][i])
            printf("%d",puzzle[k][i]);
            else printf("0");
        }
        printf("\n");
    }
    return 0;
}

//dd








11. #include <stdio.h>
int main()
{
    int n;
    scanf("%d",&n);
    int end = n-1;
    int start = 0;
	int arr [n][n];
	int number = 1;
	int k = n;
	while(k>1){
		for(int i =start;i<=end;i++){
			arr[start][i]=number;
			number ++;
		}
		for (int i = start +1;i<=end;i++){
			arr [i][end]= number++;
		}
		for (int i = end - 1;i>=start;i--){
			arr[end][i]=number;
			number ++;
		}
		for(int i = end-1;i>start;i--){
			arr[i][start]=number++;
		}
		k = k-2;
		start ++;
		end --;
	}
	if(n%2){
		arr[start][start]=number;
	}
	for(int o = 0;o<n;o++){
		for(int i =0;i<n;i++){
			if(i==0)  printf("%d",arr[o][i]);
            else
			printf(" %d",arr[o][i]);
		}
		printf("\n");
	}
	return 0;
}









12.#include<stdio.h>

int n, m;
int shuzhu[1007][1007], vis00[1007][1007];

int vaild(int x, int y)   //这里判断是否合理 
{
    if(x < 1 || x > n || y < 1 || y > m) return 0;
    if(vis00[x][y]) return 0;
    if(shuzhu[x][y] == 0) return 0;
    return 1;
}

int dx[] = {0, 1, 0, -1};
int dy[] = {1, 0, -1, 0};

void dfs(int x, int y) 
{
    vis00[x][y] = 1;
    if(x == n && y == m) 
	{
        for(int i = 1; i <= n; i++) 
		{
            for(int j = 1; j <= m; j++) 
			{
                if(j == m) printf("%d\n", vis00[i][j]);
                else printf("%d ", vis00[i][j]);
            }
        }
        vis00[x][y] = 0;
        return;
    }
    for(int i = 0; i < 4; i++) {
        int lx = x + dx[i], ly = y + dy[i];
        if(vaild(lx, ly)) dfs(lx, ly);
    }
    vis00[x][y] = 0; //如果这条路不能走，则变成0；
}

int main() {
    scanf("%d%d", &n, &m);  //取到行和列 
    for(int i = 1; i <= n; i++) 
	{
        for(int j = 1; j <= m; j++) 
		{
            scanf("%d", &shuzhu[i][j]);
        }
    }
    dfs(1, 1);
    return 0;
}
//这是个无比经典的题目，网上很多算法，现在你要看懂就好
```

# 实验六 指针

```
1
#include<stdio.h>
char *strcopy(char *,const char *);
int main()
{
    char *s1,*s2,*s3;
    char a[30],b[30],c[30];
    s1=a; s2=b; s3=c;
    scanf("%s",s2);
    strcopy(s1,s2);
    printf("%s\n",s1);
    scanf("%s",s2);
    s3 = strcopy(s1,s2);
    printf("%s\n",s3);
    return 0;
}
char *strcopy(char *t,const char *s)
{
    char *p=t;
    while(*t++=*s++);
    *t = '\0';
    return (p);
}




2
/* 实验6程序完善与修改替换第（1）题源程序：字符串升序排序 */
#include<stdio.h>
#include<stdlib.h> 
#include<string.h>
#define N 100
/* 对指针数组s指向的size个字符串进行升序排序 */
void strsort ( char *s[ ],int size )
{
    char *temp; 
    int i, j ;
    for(i=0; i<size-1; i++)
        for(j=0; j<size-i-1; j++) 
            if (strcmp(s[j],s[j+1])>0)  
{ 
                temp=s[j];
                s[j]=s[j+1];    
	            s[j+1]=temp; 
            }
 }

int main( )
{ 
    int i;
    int n;  scanf("%d",&n); 
    getchar();//吃掉缓冲区的换行
    char *s[N], t[50]; 
    for(i=0;i<N;i++)   
{
       gets(t);
       s[i] = (char *)malloc(strlen(t)+1);
       strcpy(s[i],t); 
    }
    strsort(s,n);    
    for(i=0;i<n;i++)  puts(s[i]);
    return 0;
}







3
#include<stdio.h>
#include<stdlib.h> 
#include<string.h>
#define N 100
/* 对指针数组s指向的size个字符串进行升序排序 */
void strsort ( char **s,int size )
{
    char *temp; 
    int i, j ;
    for(i=0; i<size-1; i++)
        for(j=0; j<size-i-1; j++) 
            if (strcmp(*(s+j),*(s+j+1))>0)  
{ 
                temp=*(s+j);
                *(s+j)=*(s+j+1);    
	            *(s+j+1)=temp; 
            }
 }

int main( )
{ 
    int i;
    int n;  scanf("%d",&n); 
    getchar();//吃掉缓冲区的换行
    char* s[N];
	char t[50]; 
    for(i=0;i<N;i++)   
{
       gets(t);
       *(s+i) = (char *)malloc(strlen(t)+1);
       strcpy(*(s+i),t); 
    }
    strsort(s,n);    
    for(i=0;i<n;i++)  puts(*(s+i));
    return 0;
}


4.
#include<stdio.h>
#include<string.h>
#include<stdlib.h>
int main()
{
    char*(*p)(char a[],char b[]);
	char a [80],b[80],*result;
	int choice;
	while(1){
		do {
			scanf("%d",&choice);
		}while(choice<1||choice>4);
		switch(choice)
		{
			case 1 :p =strcpy; break;
			case 2 :p =strcat; break;
			case 3 :p =strtok; break;
			case 4 :goto down;
		}
        getchar();//清除上一个留下来的换行
	gets(a);
    gets(b);
	result = p(a,b);
	printf("%s\n",result);
	}
	down :return 0;
}



5.
#include<stdio.h>
#include<string.h>
#include<stdlib.h>
int main()
{
    char*(*p[])(char a[],char b[])={strcpy,strcat,strtok};
	char a [80],b[80],*result;
	int choice;
	while(1){
		do {
			scanf("%d",&choice);
		}while(choice<1||choice>4);
		// switch(choice)
		// {
		// 	case 1 :p =strcpy; break;
		// 	case 2 :p =strcat; break;
		// 	case 3 :p =strtok; break;
		// 	case 4 :goto down;
		// }
        getchar();//清除上一个留下来的换行
        if(choice==4)
        {
         goto down;
        }
	    else
        {
        gets(a);
    gets(b);
	result = p[choice-1](a,b);
	printf("%s\n",result);
        }
	}
	down :return 0;
}






6.
#include<stdio.h>
int main()
{
	unsigned int a ;
	scanf("%u",&a);
	char * p;
	p = &a;
	for(int k=3;k>=0;k--)
	{
		p += k;
		printf("%x %x ",(char)((unsigned char)(*p)>>4),(char)((unsigned char)(*p)&0x0f));
		p -=k;
	}
	return 0;
}

7.#include<stdio.h>
#include<string.h>
void Removesame(int a[],int n)
{
	int cnt = 0;
    int b[100]={0};
    for(int i =1;i<n;i++){
        for(int j = 0;j<i;j++){
            if(a[i]==a[j])
            {
                b[i]=1;
            }
        }
    }
	for(int i = 0;i<n;i++){
		if(b[i]==0){
			cnt ++;
           if(cnt ==1)
		   {
			printf("%d",a[i]);
		   }
		   else{
			printf(" %d",a[i]);
		   }
		}
	}
	printf("\n%d",cnt);
}//dd
int main()
{
	int n;
	scanf("%d",&n);
	int a[n];
	for(int i =0;i<n;i++)
	{
		scanf("%d",&a[i]);
	}
  Removesame(a,n);
}


8.#include<stdio.h>
int main()
{
	int m,n;
	scanf("%d%d",&n,&m);
	int arr[n][m];//n是行m是列
	int arrt[m][n];//倒置后的
	for(int i=0;i<n;i++){
		for(int j =0;j<m;j++){
			scanf("%d",&arr[i][j]);
		}
	}
	for(int i =m-1,u=0;i>=0,u<m;i--,u++){//i表示列
		for(int j = 0;j<n;j++){
			//j表示行
        arrt[u][j] = arr [j][i];
	}
}
for(int i =0;i<m;i++){
	for(int j =0;j<n;j++){
		printf("%d",arrt[i][j]);
        if(j!=n-1){
            printf(" ");
        }
	}
	printf("\n");
}
return 0;
}


9.#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void sort(int a[], int len, int order)
{
    for (int i = 0; i < len; i++) //正序
        for (int j = 0; j < len - i - 1; j++)
            if (a[j] > a[j + 1])
            {
                int temp = *(a+j);
                *(a+j) = *(a+j + 1);
                *(a+j+1 )= temp;
            }
    if (order == 1)
        for (int i = 0, j = len - 1; i < j; i++, j--)
        {
            int temp = *(a+i);
            *(a+i) = *(a+j);
            *(a+j) = temp;
        }//正序后的倒序手法
}
int main(int argc,char*argv[])
{
    int N = atoi(argv[1]);
	int *a = (int *)malloc(sizeof(int) * N); 
	for (int i = 0; i < N; i++){
        scanf("%d", a+i);
	}
	if(argc==3){
		sort(a,N,1);
	}
	else{
		sort(a,N,0);
	}
    for(int k=0;k<N;k++)
        {
            printf("%d",*(a+k));
            if(k!=N-1) printf(" ");
        }//dd
    return 0;
}



10.// #include<stdio.h>
// #include<string.h>
// int subvert (char*a,char*b)
// {
//     char * check1;
//     char * check2;
//     check1 = strstr (a,b);//check1 是第一次出现目标字符串的位置
//     check2 = strstr(a,b);
//     if(check1 ==NULL){
//         return 0;//表示没找到
//     }
//     if(check1!=NULL){
//         int n =strlen(b);
//         while(check2 != NULL){
//         check1 = strstr(a,b);
//          while(*(check1+n)){
//               *check1 =*(check1+n);
//              check1++; 
//           }
//           *check1 = '\0';
//         check2 = strstr(a,b); 
//         }//DD
//         return 1;
//     }
// }
// int main()
// //{
// //     char test [100];
// //     char baga[100] ;
// //     gets(test);
// //     gets(baga);
// //     char *p,*k;
// //     int flag;
// //     //p = strstr(test,baga);//p指向的是目标的第一个出现的指针
// //     k = strstr(test,baga);
// //     if(p==NULL){
// //         flag =0;
// //         printf("%s\n",test);
// //         printf("%d",flag);
// //     }
// //     if(p!=NULL){
// //         flag = 1;
// //         // int n =strlen(baga);
// //         // while(*(p+n)){
// //         //     *p =*(p+n);
// //         //     p++; 
// //         // }
// //         // *p='\0';
// //         // printf("%s",test);
// //         while(k!=NULL){
// //             p = strstr(test,baga);
// //             int n =strlen(baga);
// //          while(*(p+n)){
// //              *p =*(p+n);
// //              p++; 
// //          }
// //          k =strstr(test,baga);
// //         }
// //         *p='\0';
// //         printf("%s\n",test);
// //         printf("%d",flag);
// //     }
// //     return 0;
// // }
// {
// char a[100],b[100];
//     gets(a); gets(b);
   
//     int k=subvert(a,b);
//     puts(a);
//     printf("%d",k);
//     return 0;
// }

//问题是aabcbcabcc这样子的会和前面的再次配对被删除

#include<stdio.h>
#include<string.h>
int delSubstr(char *p1,char *p2)
{
    char *start;   char *point;
    start=strstr(p1,p2) ;  point = strstr(p1,p2);
    if ( start == NULL) 
    return 0;
    int n=strlen(p2);
 against:   while(*(start+n))
    {
        *start=*(start+n);
        start++;  //start指向的是p1中第一次出现过重复字符串的位置
    }
    *start='\0';

    start = strstr(point ,p2);
    if(start != NULL ) 
    {
        point = strstr(point,p2);//意义在于，把检查过的前一次的字符前面的字符忽略掉，这样的话，就可以防止我写的上面那个的如aabcbcabcc这样的补上去之后，后面的和前面见擦汗过的配ui形成新的目标删除字符 这里的point可以理解是节点
        goto against;
    } 
    return 1;

}
int main()
{
    char a[100],b[100];
    gets(a); gets(b);
   
    int k=delSubstr(a,b);
    puts(a);
    printf("%d",k);
    return 0;


}
    
11.#include <stdio.h>
//#include <ctype.h>
#include <string.h>
int main()
{
    char achar [200];
    char bchar [200];//原因是只有char可以用gets函数
    gets(achar);
    gets(bchar);
    //下面我们让char转化为int
    int number1 = strlen(achar);
    int number2 = strlen(bchar);
    if(achar[0] =='0'|| bchar[0]=='0'){
        printf("0");
        return 0;//这里是如果0的话完全没有必要做下面的动作了
    }
    int a[200];
    int b[200];//转存的时候记得要从高未开始,用int可以实现运算
    for(int k =0;k<number1;k++)
    {
          a[k]=achar[number1-1-k] - '0';
    }
    for(int k =0;k<number2;k++)
    {
          b[k]=bchar[number2-1-k] - '0';
    }
    //下面模拟竖式运算
    int i =0;
    int s=0,t=0;//s是结果数组的小标
    int result[450];
    for(int k =0;k<450;k++){
        result[k]=0;//初始化
    }
    for(i=0;i<number1;i++)
    {
        for(int j =0;j<number2;j++)
        {
            result[s]=result[s]+b[j]*a[i];
            result[s+1]=result[s+1]+result[s]/10;
            result[s]=result[s]%10;
            s++;//z这个是s的增加是模拟在每一步乘法过程中的进位
        }
        t++;
        s = t;//这个的原因是在模拟每一次的话最低位的起始位置递增
    }
    s = number1 + number2;//这一步是限制s可能到的最大值
    while(result[s]==0){
        s--;//找到最高位
    }
    for(int k =s;k>=0;k--)
    {
        printf("%d",result[k]);
    }
    return 0;
}
// #define N 420
// #define max(a,b) ((a)>(b) ? (a):(b))
// void getbig (int*,int);
// void addbig (int*,int*,int*);
// #define max_num 420
// void putbig (int *);
// int main()
// {
//     int x[N+1],y[N+1],z[N+1];
//     int len,i;
//     getbig(x,N);
//     getbig(y,N);
//     addbig(x,y,z);
//     putbig(z);
//     putchar('\n');
//     return 0;
// }
// void getbig (int*x,int lim)
// {
//     int i,t,c;
//     int *p1, *p2;
//     for(i = 1;i<=lim&&isdigit(c=getchar());i++){
//         *(x+i) = c -'0';
//     }
//     *x=i-1;
//      for(p1 = x+1,p2 = x+i-1;p1<p2;p1++,p2--){
//          t= *p1;
//          *p1 = *p2;
//         *p2 = t;
//      }
// }
// void addbig(int *x,int*y,int*z)//x是上乘数，y是下乘数
// {
//     int i,carry,n,j,wid;
//     for(i = 1;i<=max_num;i++){
//         *(z+i) = 0;
//     }
//     for(i=1;i<N;i++)//i表示上乘数
//     {
//         for(j = 1,carry=0;j<N;j++){//j表示下乘数
//              *(z+i+j-2) = (*(x+i)) * (*(y+j))+carry;
//              carry = (*(z+i+j-2)) /10;
//              *(z+i+j-2) = *(z+i+j-2) %10;
//         }
//     }
// }
// void putbig (int *z)
// {
//     int  k;
//     for(k =N-1;*(z+k)==0;k--){
//           if(*(z+k-1)!=0)
//           {
//             break;
//           }
//     }
//     k = k-1;
//     int *p;
//     for( p = (z+k-1);p>=z;p--)
//     {
//         printf("%d",*p);
//     }
// }


12.#include<stdio.h>
//知识点：*p()一个指针可以指向一个函数 p=函数名
//括号里面要有函数参数的东西
void task0(void)
{
    printf("task0 is called!\n");
}
void task1(void)
{
    printf("task1 is called!\n");
}
void task2(void)
{
    printf("task2 is called!\n");
}
void task3(void)
{
    printf("task3 is called!\n");
}
void task4(void)
{
    printf("task4 is called!\n");
}
void task5(void)
{
    printf("task5 is called!\n");
}
void task6(void)
{
    printf("task6 is called!\n");
}
void task7(void)
{
    printf("task7 is called!\n");
}
void execute (void(*p)(void))
//调用函数
{
    p();
}
void scheduler(void(*p),char c)
{
   switch (c - '0')
    {
    case 1:
        p = task1;
        break;
    case 2:
        p = task2;
        break;
    case 3:
        p = task3;
        break;
    case 4:
        p = task4;
        break;
    case 5:
        p = task5;
        break;
    case 6:
        p = task6;
        break;
    case 7:
        p = task7;
        break;
    case 0:
        p = task0;
        break;
    default:
        break;
    }
    execute(p);
}
int main()
{
char c;
void (*p)(void);
while((c =getchar())!=EOF)
{
    scheduler(p,c);
}
return 0;
}
```

# 实验7 结构和联合

```
/*************************Begin*************************/
#include<stdio.h>
 char u[] = "UVWXYZ",v[]="xyz";
 struct T{
     int x;
     char c;
     char *t;

 } a[] = {
     {11,'A',u},
     {100,'B',v}
 } ,*p=a;

int main()
{
    int n;
    scanf("%d",&n);
    switch(n)
    {
        case 1 :
        printf("%d",(++p)->x);  break;
        case 2:
        p++;
        printf("%c",p->c); break;  //p的值没有增加
        case 3:
        *p++->t;
         printf("%c",*p->t);  break;
        case 4:
        printf("%c",*(++p)->t);  break;
        case 5:
        printf("%c",*++p->t);  break;
        case 6:
        printf("%c",++*p->t);break;
        default : break; 
    }
    return 0;
}










/*************************End*************************/












2.
#include <stdio.h>
#include <stdlib.h>
struct s_list{
    int data;
    struct s_list *next;
};
struct s_list* createlist(int *p);
int main(void){
    struct s_list *head,*p;
    //head = (struct s_list *)malloc((sizeof(struct s_list)));
    int s[100];
    int i = 0;
    scanf("%d",&s[i]);
    while(s[i]){
        i++;
        scanf("%d",&s[i]);
    }
    head = createlist(s);
    p=head;
    while (p){
        printf("%d\t",p->data);
        p=p->next;
    }
    printf("\n");
    return 0;  
}
 struct s_list * createlist(int *p){
    struct s_list *loc_head=NULL,*tail;
    if(p[0]==0);
    else {
        loc_head=(struct s_list *)malloc(sizeof(struct s_list));
        loc_head->data=*p++;
        tail=loc_head;
        while (*p)
        {
            tail->next=(struct s_list *)malloc(sizeof(struct s_list));
            tail=tail->next;
            tail->data=*p++;
        }
        tail->next=NULL;
    }
    return loc_head;
}


3
#include <stdio.h>
#include <stdlib.h>
struct s_list{
    int data;
    struct s_list *next;
};
struct s_list* createlist(int *p,int a);
int main(void){
    struct s_list *head,*p;
    //head = (struct s_list *)malloc((sizeof(struct s_list)));
    int s[100];
    int i = 0;
    scanf("%d",&s[i]);
    while(s[i]){
        i++;
        scanf("%d",&s[i]);
    }
    head = createlist(&s[i-1],i);
    p=head;
    while (p){
        printf("%d\t",p->data);
        p=p->next;
    }
    printf("\n");
    return 0;  
}
 struct s_list * createlist(int *p,int a){
    struct s_list *loc_head=NULL,*tail;
    if(*(p-a+1)==0);
    else {
        loc_head=(struct s_list *)malloc(sizeof(struct s_list));
        loc_head->data=*p--;
        tail=loc_head;
		int n = a - 2;
        while (n>=0)
        {
            tail->next=(struct s_list *)malloc(sizeof(struct s_list));
            tail=tail->next;
            tail->data=*p--;
			n--;
        }
        tail->next=NULL;
    }
    return loc_head;
}



4.
/*****************Begin*****************/

#include<stdio.h>
struct bits
{
    int bit0;
    int bit1;
    int bit2;
    int bit3;
    int bit4;
    int bit5;
    int bit6;
    int bit7;
} bits;
void f0(int b)
{
    printf("the function %d is called!\n",b);
}
void f1(int b){
    printf("the function %d is called!\n",b);
}
void f2(int b){
    printf("the function %d is called!\n",b);
}
void f3(int b){
    printf("the function %d is called!\n",b);
}
void f4(int b){
    printf("the function %d is called!\n",b);
}
void f5(int b){
    printf("the function %d is called!\n",b);
}
void f6(int b){
    printf("the function %d is called!\n",b);
}
void f7(int b){
    printf("the function %d is called!\n",b);
}
int main()
{
	void (*p[])(int)={f0,f1,f2,f3,f4,f5,f6,f7};
	int * a= &bits.bit0;
	int * b= &bits.bit0;
	unsigned int n;
	scanf("%u",&n);
	for(int k=0;k<8;k++)
    {
        *a=((n>>k) & 1);
        a++;
    }
	 for(int k=0;k<8;k++)
    {
        if(*b)  p[k](k);
        b++;

    }

	return 0;
}











/*****************End*****************/

5
/**********************Begin**********************/



#include <stdio.h>
#include <string.h>
#include <stdlib.h>
struct grades
{
    char ID[20];
    char name[20];
    int English;
    int math;
    int physics;
    int C;
    float a;
    struct grades *next;
};//代表每个学生的成绩单
// struct grades *  create_list(void)//funtion 1
// {
//     int n;//n is the number of the students
// 	scanf("%d",&n);
// 	int i =0;
// 	struct grades *  loc_head = NULL, *tail;
// 	//attention!point must be first operated!
// 	//now we create the HEAD POINT
// 	loc_head = (struct grades *)malloc(sizeof(struct  grades));
// 	tail = loc_head;
//     while(i<n)
// 	{
// 		tail ->next = (struct grade *)malloc(sizeof(struct grades));
// 		tail= tail -> next;
//         scanf("%s%s%d%d%d%d", &tail->ID, &tail->name, &tail->English, &tail->math, &tail->physics, &tail->C);
// 		i++;
// 	} 
// 		//next we create the other people's
//     tail->next = NULL ;
//     return loc_head;
// }
struct grades *  create_list()
{
    int n, i = 0;
    static int j = 0;//注意这里的stasic绝对不可以省略，原因是达可能会多次地哦啊用这个函数，但是只有第一次才要初始化
    scanf("%d", &n);
    static struct grades *  loc_head = NULL, *tail;
    if (j == 0)   //创立头节点 
    {
        loc_head = (struct grades *)malloc(sizeof(struct grades));
        scanf("%s%s%d%d%d%d", &loc_head->ID, &loc_head->name, &loc_head->English, &loc_head->math, &loc_head->physics, &loc_head->C);
        tail = loc_head;
        j++;
        i++;
    }
 
    for (; i < n; i++)
    {
        tail->next = (struct grades *)malloc(sizeof(struct grades));
        tail = tail->next;
        scanf("%s%s%d%d%d%d", &tail->ID, &tail->name, &tail->English, &tail->math, &tail->physics, &tail->C);
    }
    tail->next = NULL ;
    return loc_head;
}//为什么头结点有数据？如果没有数据的话，那么很悲剧，你下面的都会把头结点的0.00啥的输出
void print_list2(struct grades *headp)//fuction 2
{
    while (headp != NULL)
    {
        printf("%s %s %d %d %d %d\n", headp->ID, headp->name, headp->English, headp->math, headp->physics, headp->C);
        headp = headp->next;
    }
}
//funtion 3修改成绩
void alter(struct grades *p)
{
    int num;
    char target[20];
    scanf("%s", &target);
    while (strcmp(target, p->ID))
        p = p->next;  
    scanf("%d", &num);  //修改哪一门的成绩
    switch (num)
    {
    case 1:
        scanf("%d", &p->English);
        break;
    case 2:
        scanf("%d", &p->math);
        break;
    case 3:
        scanf("%d", &p->physics);
        break;
    case 4:
        scanf("%d", &p->C);
        break;
    default:
        break;
    }
}//这里我们使用swich语句，原因是指示词里面只有数字，则可以用swich语句表示
//fution 4 求平均数
void average(struct grades *p)
{
	while(p != NULL)
	{
		p->a = (float)(p->English + p->math + p->physics + p->C) / 4;
	    printf("%s %s %.2f\n", p->ID, p->name, p->a);
        p = p->next;
	}
}
//funtion4 输出所有成绩
void print_sum(struct grades *headp)
{
    while (headp != NULL)
    {
        headp->a = (float)(headp->English + headp->math + headp->physics + headp->C) / 4;
        printf("%s %s %d %.2f\n", headp->ID, headp->name, headp->English + headp->math + headp->physics + headp->C, headp->a);
        headp = headp->next;
    }
}
int main()
{
    struct grades *head = NULL, *p;
    int cmd = 1;
    while (cmd)
    {
        scanf("%d", &cmd);
        switch (cmd)
        {
        case 1:
            head = create_list();
            break;
        case 2:
            print_list2(head);
            break;
        case 3:
            alter(head);
            break;
        case 4:
            average(head);
            break;
        case 5:
            print_sum(head);
            break;
        default:
            break;
        }
    }
    return 0;
}









/**********************End**********************/


6
/****************************Begin****************************/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
struct grades
{
    char ID[20];
    char name[20];
    int English;
    int math;
    int physics;
    int C;
    float a;
    struct grades *next;
};//代表每个学生的成绩单
// struct grades *  create_list(void)//funtion 1
// {
//     int n;//n is the number of the students
// 	scanf("%d",&n);
// 	int i =0;
// 	struct grades *  loc_head = NULL, *tail;
// 	//attention!point must be first operated!
// 	//now we create the HEAD POINT
// 	loc_head = (struct grades *)malloc(sizeof(struct  grades));
// 	tail = loc_head;
//     while(i<n)
// 	{
// 		tail ->next = (struct grade *)malloc(sizeof(struct grades));
// 		tail= tail -> next;
//         scanf("%s%s%d%d%d%d", &tail->ID, &tail->name, &tail->English, &tail->math, &tail->physics, &tail->C);
// 		i++;
// 	} 
// 		//next we create the other people's
//     tail->next = NULL ;
//     return loc_head;
// }
struct grades *  create_list()//输入成绩
{
    int n, i = 0;
    static int j = 0;//注意这里的stasic绝对不可以省略，原因是达可能会多次地哦啊用这个函数，但是只有第一次才要初始化
    scanf("%d", &n);
    static struct grades *  loc_head = NULL, *tail;
    if (j == 0)   //创立头节点 
    {
        loc_head = (struct grades *)malloc(sizeof(struct grades));
        scanf("%s%s%d%d%d%d", &loc_head->ID, &loc_head->name, &loc_head->English, &loc_head->math, &loc_head->physics, &loc_head->C);
        tail = loc_head;
        j++;
        i++;
    }
 
    for (; i < n; i++)
    {
        tail->next = (struct grades *)malloc(sizeof(struct grades));
        tail = tail->next;
        scanf("%s%s%d%d%d%d", &tail->ID, &tail->name, &tail->English, &tail->math, &tail->physics, &tail->C);
    }
    tail->next = NULL ;
    return loc_head;
}//为什么头结点有数据？如果没有数据的话，那么很悲剧，你下面的都会把头结点的0.00啥的输出
void print_list2(struct grades *headp)//输出成绩
{
    while (headp != NULL)
    {
        printf("%s %s %d %d %d %d\n", headp->ID, headp->name, headp->English, headp->math, headp->physics, headp->C);
        headp = headp->next;
    }
}
//funtion 3修改成绩
void alter(struct grades *p)//选择修改，功能三
{
    int num;
    char target[20];
    scanf("%s", &target);
    while (strcmp(target, p->ID))
        p = p->next;  
    scanf("%d", &num);  //修改哪一门的成绩
    switch (num)
    {
    case 1:
        scanf("%d", &p->English);
        break;
    case 2:
        scanf("%d", &p->math);
        break;
    case 3:
        scanf("%d", &p->physics);
        break;
    case 4:
        scanf("%d", &p->C);
        break;
    default:
        break;
    }
}//这里我们使用swich语句，原因是指示词里面只有数字，则可以用swich语句表示
//fution 4 求平均数
void average(struct grades *p)
{
    struct grades *headp = p;
	while(p != NULL)
	{
		p->a = (float)(p->English + p->math + p->physics + p->C) / 4;
        p = p->next;
	}
    p =headp;
}
//funtion4 输出所有成绩
void print_sum(struct grades *headp)
{
    while (headp != NULL)
    {
        headp->a = (float)(headp->English + headp->math + headp->physics + headp->C) / 4;
        printf("%s %s %d %.2f\n", headp->ID, headp->name, headp->English + headp->math + headp->physics + headp->C, headp->a);
        headp = headp->next;
    }
}
void sort(struct grades *headp)//按照平均成绩排序，交换成绩
{
		struct grades *p,*tail ;
	char IDp[20];
    char namep[20];
    int Englishp;
    int mathp;
    int physicsp;
    int Cp;
    float ap;
	for(tail = NULL; headp != tail ; tail =p)
		for(p=headp ;p->next!=tail ; p=p->next)
		{
			if(p->a>p->next->a)
			{
				strcpy(IDp , p->ID); strcpy(p->ID, p->next->ID );strcpy(p->next->ID ,IDp) ;
				strcpy(namep,p->name);strcpy(p->name, p->next->name) ; strcpy(p->next->name,namep);
				Englishp = p->English;  p->English = p->next->English ; p->next->English =Englishp;
				mathp = p->math;  p->math = p->next->math ; p->next->math =mathp;
				physicsp = p->physics;  p->physics = p->next->physics ; p->next->physics=physicsp;
				Cp = p->C;  p->C = p->next->C ; p->next->C =Cp;
                ap = p->a;  p->a = p->next->a ; p->next->a =ap;
				
			}
		}
}
void printaverage(struct grades *headp)//只输出平均成绩
{
	while(headp!=NULL)
	{
		printf("%s %s %.2f\n", headp->ID, headp->name, headp->a);
		headp = headp->next;
	}
}
int main()
{
    struct grades *head = NULL, *p;
    int cmd = 1;
    while (cmd)
    {
        scanf("%d", &cmd);
        switch (cmd)
        {
        case 1:
            head = create_list();
            break;
        case 2:
            average(head);
            sort(head);
            print_list2(head);
            break;
        case 3:
            alter(head);
            break;
        case 4:
            average(head);
            sort(head);
            printaverage(head);
            break;
        case 5:
            average(head);
            sort(head);
            print_sum(head);
            break;
        default:
            break;
        }
    }
    return 0;
}








/****************************End****************************/


7
/*测试程序定义了如下结点类型
typedef struct c_node{
    char data;  struct c_node *next;
} C_NODE;
*******************************/
void createLinkList(C_NODE **headp, char s[]) 
{
/************************************* BEGIN *******************************************/
C_NODE *head,*p;
head = (C_NODE *)malloc(sizeof(C_NODE));
*headp =head;
head->data=s[0];
for(int k=1;s[k]!='\0';k++)
{
    head->next = (C_NODE *)malloc(sizeof(C_NODE));
    head = head->next;
    head->data = s[k];
    
}
head->next =NULL;


   


/************************************* BEGIN *******************************************/
}

void judgePalindrome(C_NODE *head)
{
/************************************* BEGIN *******************************************/
C_NODE *headp,*last,*new1,*flag;
headp  = head;
flag =NULL;
last = head;
while(last!=NULL)
{
    new1 =(C_NODE *)malloc(sizeof(C_NODE));
    new1->data = last->data;
    
    new1->next = flag;
    flag = new1;
    new1 = new1->next;
    last=last->next;
    
    
}
C_NODE *new2=flag;
int a=0;
while(headp!=NULL)
{
    if(headp->data!=new2->data)
    {
        a=1; break;
    }
    headp=headp->next; new2=new2->next;
}
if(a) printf("false");
else printf("true");

/************************************* BEGIN *******************************************/
}


8
/*******************************Begin*******************************/
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
struct grades
{
    char ID[20];
    char name[20];
    int English;
    int math;
    int physics;
    int C;
    float a;
    struct grades *next;
};
struct grades *create_list()
{
    int n, i = 0;
    static int j = 0;
    scanf("%d", &n);
    static struct grades *loc_head = NULL, *tail;    //static 保证了后面进入的时候不会重新再来 
    if (j == 0)
    {
        loc_head = (struct grades *)malloc(sizeof(struct grades));
        scanf("%s%s%d%d%d%d", &loc_head->ID, &loc_head->name, &loc_head->English, &loc_head->math, &loc_head->physics, &loc_head->C);
        tail = loc_head;
        j++;
        i++;
    }
  /*  while (tail->next != NULL)
        tail = tail->next;*/
    for (; i < n; i++)
    {
        tail->next = (struct grades *)malloc(sizeof(struct grades));    //分配空间 
        tail = tail->next;
        scanf("%s%s%d%d%d%d", &tail->ID, &tail->name, &tail->English, &tail->math, &tail->physics, &tail->C);
    }
    tail->next = NULL;
    return loc_head;
}
void sort(struct grades **headp)
{
		struct grades *head,*p,*last,*tail ;
	char IDp[20];
    char namep[20];
    int Englishp;
    int mathp;
    int physicsp;
    int Cp;
    float ap;
    head =(struct grades *)malloc(sizeof(struct grades));
    head->next = *headp;
	for(tail = NULL; head->next != tail ; tail =p)
		for(last =head ,p=head->next ;p->next != tail ;last = p,p=p->next)
		{
			if(p->a>p->next->a)
			{
				last->next = p->next;   //解决头的连接
                p->next = p->next->next;  //解决尾部的连接
                last->next->next=p;      // 解决中间的连接，其他的都已经搞定了
                p=last->next;

			}
		}
        *headp = head->next;
        free(head);
}
void print_list(struct grades *headp)
{
	
    while (headp != NULL)
    {
        printf("%s %s %d %d %d %d\n", headp->ID, headp->name, headp->English, headp->math, headp->physics, headp->C);
        headp = headp->next;
    }
}
void alter(struct grades *p)
{
    int num;
    char target[20];
    scanf("%s", &target);
    while (strcmp(target, p->ID))
        p = p->next;
    scanf("%d", &num);
    switch (num)
    {
    case 1:
        scanf("%d", &p->English);
        break;
    case 2:
        scanf("%d", &p->math);
        break;
    case 3:
        scanf("%d", &p->physics);
        break;
    case 4:
        scanf("%d", &p->C);
        break;
    default:
        break;
    }
}
void average(struct grades **p)
{
	struct grades *head; head=(*p);
    while (*p != NULL)
    {
        (*p)->a = (float)((*p)->English + (*p)->math + (*p)->physics + (*p)->C) / 4;
       // printf("%s %s %.2f\n", p->ID, p->name, p->a);
        (*p) = (*p)->next;
    }
    (*p) = head;
}
void printaverage(struct grades *headp)
{
	while(headp!=NULL)
	{
		printf("%s %s %.2f\n", headp->ID, headp->name, headp->a);
		headp = headp->next;
	}
}
void print_sum(struct grades *headp)
{
    while (headp != NULL)
    {
        headp->a = (float)(headp->English + headp->math + headp->physics + headp->C) / 4;
        printf("%s %s %d %.2f\n", headp->ID, headp->name, headp->English + headp->math + headp->physics + headp->C, headp->a);
        headp = headp->next;
    }
}
int main()
{
    struct grades *head = NULL, *p;
    int cmd = 1;
    while (cmd)
    {
        scanf("%d", &cmd);
        switch (cmd)
        {
        case 1:
            head = create_list();
            break;
        case 2:
        	average(&head);
        	sort(&head);
            print_list(head);
            break;
        case 3:
            alter(head);
            break;
        case 4:
        	
            average(&head);
            sort(&head);
            printaverage(head);
            break;
        case 5:
        	average(&head);
            sort(&head);
            print_sum(head);
            break;
        default:
            break;
        }
    }
    return 0;
}






/*******************************End*******************************/



9.
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>

#define SIZE 1024

double stack[SIZE];
double *top = stack;

void push(int x) {
    if (top == stack + SIZE) {
        printf("stack is full");
        exit(EXIT_FAILURE);
    }
    *top++ = x;
}

double pop(void) {
    if (top == stack) {
        printf("stack is empty");
        exit(EXIT_FAILURE);
    }
    return *--top;
}

int main() {
    char token[SIZE];


    while (scanf("%s", token) != EOF) {
        if (isdigit(token[0]) || (token[0] == '-' && isdigit(token[1]))) {
            push(atof(token));
        } else {
            switch (token[0]) {
                case '+':
                    push(pop() + pop());
                    break;
                case '-':
                    if (top - stack < 2) {
                        printf("Invalid expression: insufficient operands\n");
                        return -1;
                    }
                    double x = pop();
                    push(pop() - x);
                    break;
                case '*':
                    push(pop() * pop());
                    break;
                case '/':
                    x = pop();
                    if (x == 0) {
                        printf("Division by zero error\n");
                        return -1;
                    }
                    push(pop() / x);
                    break;
                default:
                    printf("unknown operator\n");
                    return -1;
            }
        }
    }

    if (top - stack != 1) {
        printf("Invalid expression: too many operands\n");
        return -1;
    }

    printf("%.0f\n", pop());

    return 0;
}






/********************************End********************************/
```

# 实验8 文件

```
#include<stdio.h>
#include<stdlib.h>
int main(int argc, char* argv[])
{
	FILE * fp;
    char tmp[100];
	if(argc!=2){ 
		printf("Arguments error!\n");
		exit(-1); 
	}
	if((fp=fopen(argv[1],"r"))==NULL){      /* fp指向filename */
		printf("Can't open %s file!\n", argv[1]);
		exit(-1);
	}
	while(!feof(fp))
    {
        fgets(tmp,100,fp);
        printf("%s",tmp); 
    }             
		   
                                         /* 向显示器中写从filename中读取的字符 */ 
	fclose(fp);                        /* 关闭filename */ 
	return 0;
}

2
#include<stdio.h>
#include<stdlib.h>
int main(int argc, char* argv[])
{
	FILE * fp;
    char tmp [100];
	if(argc!=3){
		printf("Arguments error!\n");
		exit(-1);
	}
	if((fp=fopen(argv[1],"r"))==NULL){      /* fp指向filename */
		printf("Can't open %s file!\n", argv[1]);
		exit(-1);
	}
    int flag =0;
    char order;
    	while(!feof(fp))             
		{
            fgets(tmp,100,fp);
            printf("%d %s",++flag,tmp);
            if(flag ==5){
                scanf("%c",&order);
            }
        }            /* 向显示器中写从filename中读取的字符 */ 
	fclose(fp);                        /* 关闭filename */ 
	return 0;
}


3
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
void change(char *bechange,char *tochange,char *douc,char *out)
{
    char *doucp,*outp,*p;
    int lento,len,lenbe;
    lento = strlen(tochange);  
    lenbe = strlen(bechange);
    doucp = douc;  outp = out;
    p = strstr(doucp,bechange);   //记录出现you的位置

    if(p)
    {
       while(p)
    {
        len = (int )(p-doucp);
        memcpy(outp,doucp,len);
        memcpy(outp+len,tochange,lento);

        doucp = p+lenbe;   
        outp = outp + len +lento;
        p = strstr(doucp,bechange);

    } 
   strcpy(outp,doucp);
    }
    
    else{ strcpy(outp,doucp);}


}
int main(int argc,char *argv[])
{
    if(argc!=4)
    {
    printf("error");
    exit(-1);
    }
    char tmp[100];  FILE *fp =fopen(argv[1],"r");
    freopen("out.txt","w",stdout);
    while(fgets(tmp,100,fp))
    {
        char out[100];
        change(argv[2],argv[3],tmp,out);
        printf("%s",out);

    }
    fclose(fp);
   


    
    
}



4
//
#include<stdio.h>
#include<stdlib.h>
void input()
{

    FILE *fp;
    if((fp=fopen("float.dat","wb"))==NULL)
    {
        printf("error");
        exit(-1);
    }
    float number[14];
    for(int k=0;k<10;k++){
        scanf("%f",&number[k]);
        fprintf(fp,"%f %c",number[k],' ');
    }
    fclose(fp);
}
void output()
{
    FILE *fp;
    if((fp=fopen("float.dat","rw"))==NULL)
    {
        printf("error");
        exit(-1);
    }
    //这里我们结合位运算，让他的各位可以诸葛打印出来，注意unsign char
    float num[14];
    for(int i=0;i<10;i++)
    {
        fscanf(fp,"%f",&num[i]);
        int m,j,k;
        unsigned char*p=(unsigned char*)&num[i]+3;
        //因为float占四个字节，强制一下，升到高位先
        for(m=0;m<4;m++)
        {
            j=*(p-m);
            for(k=7;k>=0;k--)
            {
                if(j&(1<<k)){
                    printf("1");
                }
                else{
                    printf("0");
                }
            }
        }
        printf("\n");
    }
    fclose(fp);
}
int main()
{
    input();
    output();
}


5.

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
int number =0;
struct grades
{
    char ID[20];
    char name[20];
    int English;
    int math;
    int physics;
    int C;
    float a;
    struct grades *next;
};
struct grades *create_list()
{
    int n, i = 0;
    static int j = 0;
    scanf("%d", &n);
    number = number+n;
    static struct grades *loc_head = NULL, *tail;    //static 保证了后面进入的时候不会重新再来 
    if (j == 0)
    {
        loc_head = (struct grades *)malloc(sizeof(struct grades));
        scanf("%s%s%d%d%d%d", &loc_head->ID, &loc_head->name, &loc_head->English, &loc_head->math, &loc_head->physics, &loc_head->C);
        tail = loc_head;
        j++;
        i++;
    }
  /*  while (tail->next != NULL)
        tail = tail->next;*/
    for (; i < n; i++)
    {
        tail->next = (struct grades *)malloc(sizeof(struct grades));    //分配空间 
        tail = tail->next;
        scanf("%s%s%d%d%d%d", &tail->ID, &tail->name, &tail->English, &tail->math, &tail->physics, &tail->C);
    }
    tail->next = NULL;
    return loc_head;
}
void sort(struct grades **headp)
{
		struct grades *head,*p,*last,*tail ;
	char IDp[20];
    char namep[20];
    int Englishp;
    int mathp;
    int physicsp;
    int Cp;
    float ap;
    head =(struct grades *)malloc(sizeof(struct grades));
    head->next = *headp;
	for(tail = NULL; head->next != tail ; tail =p)
		for(last =head ,p=head->next ;p->next != tail ;last = p,p=p->next)
		{
			if(p->a>p->next->a)
			{
				last->next = p->next;   //解决头的连接
                p->next = p->next->next;  //解决尾部的连接
                last->next->next=p;      // 解决中间的连接，其他的都已经搞定了
                p=last->next;

			}
		}
        *headp = head->next;
        free(head);
}
void print_list(struct grades *headp)
{
	
    while (headp != NULL)
    {
        printf("%s %s %d %d %d %d\n", headp->ID, headp->name, headp->English, headp->math, headp->physics, headp->C);
        headp = headp->next;
    }
}
void alter(struct grades *p)
{
    int num;
    char target[20];
    scanf("%s", &target);
    while (strcmp(target, p->ID))
        p = p->next;
    scanf("%d", &num);
    switch (num)
    {
    case 1:
        scanf("%d", &p->English);
        break;
    case 2:
        scanf("%d", &p->math);
        break;
    case 3:
        scanf("%d", &p->physics);
        break;
    case 4:
        scanf("%d", &p->C);
        break;
    default:
        break;
    }
}
void average(struct grades **p)
{
	struct grades *head; head=(*p);
    while (*p != NULL)
    {
        (*p)->a = (float)((*p)->English + (*p)->math + (*p)->physics + (*p)->C) / 4;
       // printf("%s %s %.2f\n", p->ID, p->name, p->a);
        (*p) = (*p)->next;
    }
    (*p) = head;
}
void printaverage(struct grades *headp)
{
	while(headp!=NULL)
	{
		printf("%s %s %.2f\n", headp->ID, headp->name, headp->a);
		headp = headp->next;
	}
}
void print_sum(struct grades *headp)
{
    while (headp != NULL)
    {
        headp->a = (float)(headp->English + headp->math + headp->physics + headp->C) / 4;
        printf("%s %s %d %.2f\n", headp->ID, headp->name, headp->English + headp->math + headp->physics + headp->C, headp->a);
        headp = headp->next;
    }
}
void function6(struct grades *head)
{
    struct grades* headp= head;
    FILE *fp;
    if((fp=fopen("stu.dat","wb")) == NULL)
    {
        printf("can't open the file");
        exit (-1);
    }
    fwrite(headp,sizeof(struct grade*),number,fp);
    fclose(fp);
}
int main()
{
    struct grades *head = NULL, *p;
    int cmd = 1;
    while (cmd)
    {
        scanf("%d", &cmd);
        switch (cmd)
        {
        case 1:
            head = create_list();
            break;
        case 2:
        	average(&head);
        	//sort(&head);
            print_list(head);
            break;
        case 3:
            alter(head);
            break;
        case 4:
        	
            average(&head);
            //sort(&head);
            printaverage(head);
            break;
        case 5:
        	average(&head);
            //sort(&head);
            print_sum(head);
            break;
        case 6:
            function6(head);
            break;
        case 7:
             
        default:
            break;
        }
    }
    return 0;
}






/*******************************End*******************************/


6.
#include<stdio.h>
#include<stdlib.h>
int main(){
    char target[10]; 
    scanf("%s",target);
    char *p =target;
    FILE *fp1,*fp2;
    fp1 =fopen(p,"r");
    fp2 =fopen("matrix.out","w");
    int number[100];
   fscanf(fp1,"%d",&number[0]);
   fscanf(fp1,"%d",&number[1]);
   int  n,m;
   n = number[0];
   m = number[1]; int flag=1;int tmp[10][10];
  for(int k=0 ; k<n ; k++)
  {
      for(int i=0;i<m ;i++)
      {
          ++flag;
          fscanf(fp1,"%d",&number[flag]);   //要一个一个的取出
          tmp[k][i]=number[flag];
      }
  }
  int la[10][10];
  for(int k=0;k<m;k++)
  {
      for(int i=0;i<n ;i++)
      {   if(i) fprintf(fp2,"%c",' ');
          la[k][i] = tmp[i][m-1-k];
          fprintf(fp2,"%d",la[k][i]);
      }
      fprintf(fp2,"%c",'\n');
  }
 // fwrite(&la[0],sizeof(int),m*n,fp2);
 
  fclose(fp1);
  fclose(fp2);
	return 0;
}
```

